// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gomeetfaker.proto

/*
Package gomeetfaker is a generated protocol buffer package.

It is generated from these files:
	gomeetfaker.proto

It has these top-level messages:
	FieldFakerRules
	ValueRules
	UuidRules
	EnumRules
	AddressRules
	AddressRulesByState
	AppRules
	AvatarRules
	AvatarUrlRules
	BitcoinRules
	BusinessRules
	CodeRules
	CommerceRules
	CompanyRules
	DateRules
	DateRulesBirthday
	DateRulesBetween
	FinanceRules
	FinanceRulesCreditCard
	HackerRules
	InternetRules
	InternetRulesPassword
	LoremRules
	LoremRulesNum
	LoremRulesSentence
	LoremRulesParagraph
	NameRules
	NumberRules
	NumberRulesDigit
	NumberRulesDecimal
	NumberRulesBetween
	NumberRulesPositive
	NumberRulesNegative
	NumberRulesCount
	NumberRulesCount2
	PhoneNumberRules
	PhoneNumberRulesDigit
	TeamRules
	TimeRules
	TimeRulesBirthday
	TimeRulesBetween
*/
package gomeetfaker

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
import _ "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type FieldFakerRules struct {
	// Types that are valid to be assigned to Type:
	//	*FieldFakerRules_Value
	//	*FieldFakerRules_Uuid
	//	*FieldFakerRules_Enum
	//	*FieldFakerRules_Address
	//	*FieldFakerRules_App
	//	*FieldFakerRules_Avatar
	//	*FieldFakerRules_Bitcoin
	//	*FieldFakerRules_Business
	//	*FieldFakerRules_Code
	//	*FieldFakerRules_Commerce
	//	*FieldFakerRules_Company
	//	*FieldFakerRules_Date
	//	*FieldFakerRules_Finance
	//	*FieldFakerRules_Hacker
	//	*FieldFakerRules_Internet
	//	*FieldFakerRules_Lorem
	//	*FieldFakerRules_Name
	//	*FieldFakerRules_Number
	//	*FieldFakerRules_PhoneNumber
	//	*FieldFakerRules_Team
	//	*FieldFakerRules_Time
	//	*FieldFakerRules_Repeated
	//	*FieldFakerRules_Skip
	Type             isFieldFakerRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *FieldFakerRules) Reset()                    { *m = FieldFakerRules{} }
func (m *FieldFakerRules) String() string            { return proto.CompactTextString(m) }
func (*FieldFakerRules) ProtoMessage()               {}
func (*FieldFakerRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{0} }

type isFieldFakerRules_Type interface {
	isFieldFakerRules_Type()
}

type FieldFakerRules_Value struct {
	Value *ValueRules `protobuf:"bytes,1,opt,name=value,oneof"`
}
type FieldFakerRules_Uuid struct {
	Uuid *UuidRules `protobuf:"bytes,2,opt,name=uuid,oneof"`
}
type FieldFakerRules_Enum struct {
	Enum *EnumRules `protobuf:"bytes,3,opt,name=enum,oneof"`
}
type FieldFakerRules_Address struct {
	Address *AddressRules `protobuf:"bytes,4,opt,name=address,oneof"`
}
type FieldFakerRules_App struct {
	App *AppRules `protobuf:"bytes,5,opt,name=app,oneof"`
}
type FieldFakerRules_Avatar struct {
	Avatar *AvatarRules `protobuf:"bytes,6,opt,name=avatar,oneof"`
}
type FieldFakerRules_Bitcoin struct {
	Bitcoin *BitcoinRules `protobuf:"bytes,7,opt,name=bitcoin,oneof"`
}
type FieldFakerRules_Business struct {
	Business *BusinessRules `protobuf:"bytes,8,opt,name=business,oneof"`
}
type FieldFakerRules_Code struct {
	Code *CodeRules `protobuf:"bytes,9,opt,name=code,oneof"`
}
type FieldFakerRules_Commerce struct {
	Commerce *CommerceRules `protobuf:"bytes,10,opt,name=commerce,oneof"`
}
type FieldFakerRules_Company struct {
	Company *CompanyRules `protobuf:"bytes,11,opt,name=company,oneof"`
}
type FieldFakerRules_Date struct {
	Date *DateRules `protobuf:"bytes,12,opt,name=date,oneof"`
}
type FieldFakerRules_Finance struct {
	Finance *FinanceRules `protobuf:"bytes,13,opt,name=finance,oneof"`
}
type FieldFakerRules_Hacker struct {
	Hacker *HackerRules `protobuf:"bytes,14,opt,name=hacker,oneof"`
}
type FieldFakerRules_Internet struct {
	Internet *InternetRules `protobuf:"bytes,15,opt,name=internet,oneof"`
}
type FieldFakerRules_Lorem struct {
	Lorem *LoremRules `protobuf:"bytes,16,opt,name=lorem,oneof"`
}
type FieldFakerRules_Name struct {
	Name *NameRules `protobuf:"bytes,17,opt,name=name,oneof"`
}
type FieldFakerRules_Number struct {
	Number *NumberRules `protobuf:"bytes,18,opt,name=number,oneof"`
}
type FieldFakerRules_PhoneNumber struct {
	PhoneNumber *PhoneNumberRules `protobuf:"bytes,19,opt,name=phone_number,json=phoneNumber,oneof"`
}
type FieldFakerRules_Team struct {
	Team *TeamRules `protobuf:"bytes,20,opt,name=team,oneof"`
}
type FieldFakerRules_Time struct {
	Time *TimeRules `protobuf:"bytes,21,opt,name=time,oneof"`
}
type FieldFakerRules_Repeated struct {
	Repeated uint32 `protobuf:"varint,22,opt,name=repeated,oneof"`
}
type FieldFakerRules_Skip struct {
	Skip bool `protobuf:"varint,23,opt,name=skip,oneof"`
}

func (*FieldFakerRules_Value) isFieldFakerRules_Type()       {}
func (*FieldFakerRules_Uuid) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Enum) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Address) isFieldFakerRules_Type()     {}
func (*FieldFakerRules_App) isFieldFakerRules_Type()         {}
func (*FieldFakerRules_Avatar) isFieldFakerRules_Type()      {}
func (*FieldFakerRules_Bitcoin) isFieldFakerRules_Type()     {}
func (*FieldFakerRules_Business) isFieldFakerRules_Type()    {}
func (*FieldFakerRules_Code) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Commerce) isFieldFakerRules_Type()    {}
func (*FieldFakerRules_Company) isFieldFakerRules_Type()     {}
func (*FieldFakerRules_Date) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Finance) isFieldFakerRules_Type()     {}
func (*FieldFakerRules_Hacker) isFieldFakerRules_Type()      {}
func (*FieldFakerRules_Internet) isFieldFakerRules_Type()    {}
func (*FieldFakerRules_Lorem) isFieldFakerRules_Type()       {}
func (*FieldFakerRules_Name) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Number) isFieldFakerRules_Type()      {}
func (*FieldFakerRules_PhoneNumber) isFieldFakerRules_Type() {}
func (*FieldFakerRules_Team) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Time) isFieldFakerRules_Type()        {}
func (*FieldFakerRules_Repeated) isFieldFakerRules_Type()    {}
func (*FieldFakerRules_Skip) isFieldFakerRules_Type()        {}

func (m *FieldFakerRules) GetType() isFieldFakerRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *FieldFakerRules) GetValue() *ValueRules {
	if x, ok := m.GetType().(*FieldFakerRules_Value); ok {
		return x.Value
	}
	return nil
}

func (m *FieldFakerRules) GetUuid() *UuidRules {
	if x, ok := m.GetType().(*FieldFakerRules_Uuid); ok {
		return x.Uuid
	}
	return nil
}

func (m *FieldFakerRules) GetEnum() *EnumRules {
	if x, ok := m.GetType().(*FieldFakerRules_Enum); ok {
		return x.Enum
	}
	return nil
}

func (m *FieldFakerRules) GetAddress() *AddressRules {
	if x, ok := m.GetType().(*FieldFakerRules_Address); ok {
		return x.Address
	}
	return nil
}

func (m *FieldFakerRules) GetApp() *AppRules {
	if x, ok := m.GetType().(*FieldFakerRules_App); ok {
		return x.App
	}
	return nil
}

func (m *FieldFakerRules) GetAvatar() *AvatarRules {
	if x, ok := m.GetType().(*FieldFakerRules_Avatar); ok {
		return x.Avatar
	}
	return nil
}

func (m *FieldFakerRules) GetBitcoin() *BitcoinRules {
	if x, ok := m.GetType().(*FieldFakerRules_Bitcoin); ok {
		return x.Bitcoin
	}
	return nil
}

func (m *FieldFakerRules) GetBusiness() *BusinessRules {
	if x, ok := m.GetType().(*FieldFakerRules_Business); ok {
		return x.Business
	}
	return nil
}

func (m *FieldFakerRules) GetCode() *CodeRules {
	if x, ok := m.GetType().(*FieldFakerRules_Code); ok {
		return x.Code
	}
	return nil
}

func (m *FieldFakerRules) GetCommerce() *CommerceRules {
	if x, ok := m.GetType().(*FieldFakerRules_Commerce); ok {
		return x.Commerce
	}
	return nil
}

func (m *FieldFakerRules) GetCompany() *CompanyRules {
	if x, ok := m.GetType().(*FieldFakerRules_Company); ok {
		return x.Company
	}
	return nil
}

func (m *FieldFakerRules) GetDate() *DateRules {
	if x, ok := m.GetType().(*FieldFakerRules_Date); ok {
		return x.Date
	}
	return nil
}

func (m *FieldFakerRules) GetFinance() *FinanceRules {
	if x, ok := m.GetType().(*FieldFakerRules_Finance); ok {
		return x.Finance
	}
	return nil
}

func (m *FieldFakerRules) GetHacker() *HackerRules {
	if x, ok := m.GetType().(*FieldFakerRules_Hacker); ok {
		return x.Hacker
	}
	return nil
}

func (m *FieldFakerRules) GetInternet() *InternetRules {
	if x, ok := m.GetType().(*FieldFakerRules_Internet); ok {
		return x.Internet
	}
	return nil
}

func (m *FieldFakerRules) GetLorem() *LoremRules {
	if x, ok := m.GetType().(*FieldFakerRules_Lorem); ok {
		return x.Lorem
	}
	return nil
}

func (m *FieldFakerRules) GetName() *NameRules {
	if x, ok := m.GetType().(*FieldFakerRules_Name); ok {
		return x.Name
	}
	return nil
}

func (m *FieldFakerRules) GetNumber() *NumberRules {
	if x, ok := m.GetType().(*FieldFakerRules_Number); ok {
		return x.Number
	}
	return nil
}

func (m *FieldFakerRules) GetPhoneNumber() *PhoneNumberRules {
	if x, ok := m.GetType().(*FieldFakerRules_PhoneNumber); ok {
		return x.PhoneNumber
	}
	return nil
}

func (m *FieldFakerRules) GetTeam() *TeamRules {
	if x, ok := m.GetType().(*FieldFakerRules_Team); ok {
		return x.Team
	}
	return nil
}

func (m *FieldFakerRules) GetTime() *TimeRules {
	if x, ok := m.GetType().(*FieldFakerRules_Time); ok {
		return x.Time
	}
	return nil
}

func (m *FieldFakerRules) GetRepeated() uint32 {
	if x, ok := m.GetType().(*FieldFakerRules_Repeated); ok {
		return x.Repeated
	}
	return 0
}

func (m *FieldFakerRules) GetSkip() bool {
	if x, ok := m.GetType().(*FieldFakerRules_Skip); ok {
		return x.Skip
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FieldFakerRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FieldFakerRules_OneofMarshaler, _FieldFakerRules_OneofUnmarshaler, _FieldFakerRules_OneofSizer, []interface{}{
		(*FieldFakerRules_Value)(nil),
		(*FieldFakerRules_Uuid)(nil),
		(*FieldFakerRules_Enum)(nil),
		(*FieldFakerRules_Address)(nil),
		(*FieldFakerRules_App)(nil),
		(*FieldFakerRules_Avatar)(nil),
		(*FieldFakerRules_Bitcoin)(nil),
		(*FieldFakerRules_Business)(nil),
		(*FieldFakerRules_Code)(nil),
		(*FieldFakerRules_Commerce)(nil),
		(*FieldFakerRules_Company)(nil),
		(*FieldFakerRules_Date)(nil),
		(*FieldFakerRules_Finance)(nil),
		(*FieldFakerRules_Hacker)(nil),
		(*FieldFakerRules_Internet)(nil),
		(*FieldFakerRules_Lorem)(nil),
		(*FieldFakerRules_Name)(nil),
		(*FieldFakerRules_Number)(nil),
		(*FieldFakerRules_PhoneNumber)(nil),
		(*FieldFakerRules_Team)(nil),
		(*FieldFakerRules_Time)(nil),
		(*FieldFakerRules_Repeated)(nil),
		(*FieldFakerRules_Skip)(nil),
	}
}

func _FieldFakerRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FieldFakerRules)
	// type
	switch x := m.Type.(type) {
	case *FieldFakerRules_Value:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Value); err != nil {
			return err
		}
	case *FieldFakerRules_Uuid:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Uuid); err != nil {
			return err
		}
	case *FieldFakerRules_Enum:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Enum); err != nil {
			return err
		}
	case *FieldFakerRules_Address:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Address); err != nil {
			return err
		}
	case *FieldFakerRules_App:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.App); err != nil {
			return err
		}
	case *FieldFakerRules_Avatar:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Avatar); err != nil {
			return err
		}
	case *FieldFakerRules_Bitcoin:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bitcoin); err != nil {
			return err
		}
	case *FieldFakerRules_Business:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Business); err != nil {
			return err
		}
	case *FieldFakerRules_Code:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Code); err != nil {
			return err
		}
	case *FieldFakerRules_Commerce:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Commerce); err != nil {
			return err
		}
	case *FieldFakerRules_Company:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Company); err != nil {
			return err
		}
	case *FieldFakerRules_Date:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Date); err != nil {
			return err
		}
	case *FieldFakerRules_Finance:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Finance); err != nil {
			return err
		}
	case *FieldFakerRules_Hacker:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hacker); err != nil {
			return err
		}
	case *FieldFakerRules_Internet:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Internet); err != nil {
			return err
		}
	case *FieldFakerRules_Lorem:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Lorem); err != nil {
			return err
		}
	case *FieldFakerRules_Name:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Name); err != nil {
			return err
		}
	case *FieldFakerRules_Number:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Number); err != nil {
			return err
		}
	case *FieldFakerRules_PhoneNumber:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhoneNumber); err != nil {
			return err
		}
	case *FieldFakerRules_Team:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Team); err != nil {
			return err
		}
	case *FieldFakerRules_Time:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Time); err != nil {
			return err
		}
	case *FieldFakerRules_Repeated:
		_ = b.EncodeVarint(22<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Repeated))
	case *FieldFakerRules_Skip:
		t := uint64(0)
		if x.Skip {
			t = 1
		}
		_ = b.EncodeVarint(23<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("FieldFakerRules.Type has unexpected type %T", x)
	}
	return nil
}

func _FieldFakerRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FieldFakerRules)
	switch tag {
	case 1: // type.value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ValueRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Value{msg}
		return true, err
	case 2: // type.uuid
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UuidRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Uuid{msg}
		return true, err
	case 3: // type.enum
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EnumRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Enum{msg}
		return true, err
	case 4: // type.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Address{msg}
		return true, err
	case 5: // type.app
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_App{msg}
		return true, err
	case 6: // type.avatar
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AvatarRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Avatar{msg}
		return true, err
	case 7: // type.bitcoin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BitcoinRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Bitcoin{msg}
		return true, err
	case 8: // type.business
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BusinessRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Business{msg}
		return true, err
	case 9: // type.code
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CodeRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Code{msg}
		return true, err
	case 10: // type.commerce
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommerceRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Commerce{msg}
		return true, err
	case 11: // type.company
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CompanyRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Company{msg}
		return true, err
	case 12: // type.date
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DateRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Date{msg}
		return true, err
	case 13: // type.finance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FinanceRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Finance{msg}
		return true, err
	case 14: // type.hacker
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HackerRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Hacker{msg}
		return true, err
	case 15: // type.internet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InternetRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Internet{msg}
		return true, err
	case 16: // type.lorem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Lorem{msg}
		return true, err
	case 17: // type.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NameRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Name{msg}
		return true, err
	case 18: // type.number
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Number{msg}
		return true, err
	case 19: // type.phone_number
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PhoneNumberRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_PhoneNumber{msg}
		return true, err
	case 20: // type.team
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TeamRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Team{msg}
		return true, err
	case 21: // type.time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimeRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldFakerRules_Time{msg}
		return true, err
	case 22: // type.repeated
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &FieldFakerRules_Repeated{uint32(x)}
		return true, err
	case 23: // type.skip
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &FieldFakerRules_Skip{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _FieldFakerRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FieldFakerRules)
	// type
	switch x := m.Type.(type) {
	case *FieldFakerRules_Value:
		s := proto.Size(x.Value)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Uuid:
		s := proto.Size(x.Uuid)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Enum:
		s := proto.Size(x.Enum)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Address:
		s := proto.Size(x.Address)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_App:
		s := proto.Size(x.App)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Avatar:
		s := proto.Size(x.Avatar)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Bitcoin:
		s := proto.Size(x.Bitcoin)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Business:
		s := proto.Size(x.Business)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Code:
		s := proto.Size(x.Code)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Commerce:
		s := proto.Size(x.Commerce)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Company:
		s := proto.Size(x.Company)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Date:
		s := proto.Size(x.Date)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Finance:
		s := proto.Size(x.Finance)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Hacker:
		s := proto.Size(x.Hacker)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Internet:
		s := proto.Size(x.Internet)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Lorem:
		s := proto.Size(x.Lorem)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Name:
		s := proto.Size(x.Name)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Number:
		s := proto.Size(x.Number)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_PhoneNumber:
		s := proto.Size(x.PhoneNumber)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Team:
		s := proto.Size(x.Team)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Time:
		s := proto.Size(x.Time)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldFakerRules_Repeated:
		n += proto.SizeVarint(22<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Repeated))
	case *FieldFakerRules_Skip:
		n += proto.SizeVarint(23<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ValueRules struct {
	Repeated         *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	Content          *string `protobuf:"bytes,2,req,name=content" json:"content,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ValueRules) Reset()                    { *m = ValueRules{} }
func (m *ValueRules) String() string            { return proto.CompactTextString(m) }
func (*ValueRules) ProtoMessage()               {}
func (*ValueRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{1} }

func (m *ValueRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *ValueRules) GetContent() string {
	if m != nil && m.Content != nil {
		return *m.Content
	}
	return ""
}

type UuidRules struct {
	Repeated         *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	Version          *string `protobuf:"bytes,2,req,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UuidRules) Reset()                    { *m = UuidRules{} }
func (m *UuidRules) String() string            { return proto.CompactTextString(m) }
func (*UuidRules) ProtoMessage()               {}
func (*UuidRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{2} }

func (m *UuidRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *UuidRules) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

type EnumRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*EnumRules_Random
	//	*EnumRules_First
	//	*EnumRules_Last
	//	*EnumRules_Index
	//	*EnumRules_Value
	//	*EnumRules_RandomNoEmpty
	Type             isEnumRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *EnumRules) Reset()                    { *m = EnumRules{} }
func (m *EnumRules) String() string            { return proto.CompactTextString(m) }
func (*EnumRules) ProtoMessage()               {}
func (*EnumRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{3} }

type isEnumRules_Type interface {
	isEnumRules_Type()
}

type EnumRules_Random struct {
	Random bool `protobuf:"varint,2,opt,name=random,oneof"`
}
type EnumRules_First struct {
	First bool `protobuf:"varint,3,opt,name=first,oneof"`
}
type EnumRules_Last struct {
	Last bool `protobuf:"varint,4,opt,name=last,oneof"`
}
type EnumRules_Index struct {
	Index uint32 `protobuf:"varint,5,opt,name=index,oneof"`
}
type EnumRules_Value struct {
	Value uint32 `protobuf:"varint,6,opt,name=value,oneof"`
}
type EnumRules_RandomNoEmpty struct {
	RandomNoEmpty bool `protobuf:"varint,7,opt,name=random_no_empty,json=randomNoEmpty,oneof"`
}

func (*EnumRules_Random) isEnumRules_Type()        {}
func (*EnumRules_First) isEnumRules_Type()         {}
func (*EnumRules_Last) isEnumRules_Type()          {}
func (*EnumRules_Index) isEnumRules_Type()         {}
func (*EnumRules_Value) isEnumRules_Type()         {}
func (*EnumRules_RandomNoEmpty) isEnumRules_Type() {}

func (m *EnumRules) GetType() isEnumRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *EnumRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *EnumRules) GetRandom() bool {
	if x, ok := m.GetType().(*EnumRules_Random); ok {
		return x.Random
	}
	return false
}

func (m *EnumRules) GetFirst() bool {
	if x, ok := m.GetType().(*EnumRules_First); ok {
		return x.First
	}
	return false
}

func (m *EnumRules) GetLast() bool {
	if x, ok := m.GetType().(*EnumRules_Last); ok {
		return x.Last
	}
	return false
}

func (m *EnumRules) GetIndex() uint32 {
	if x, ok := m.GetType().(*EnumRules_Index); ok {
		return x.Index
	}
	return 0
}

func (m *EnumRules) GetValue() uint32 {
	if x, ok := m.GetType().(*EnumRules_Value); ok {
		return x.Value
	}
	return 0
}

func (m *EnumRules) GetRandomNoEmpty() bool {
	if x, ok := m.GetType().(*EnumRules_RandomNoEmpty); ok {
		return x.RandomNoEmpty
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EnumRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EnumRules_OneofMarshaler, _EnumRules_OneofUnmarshaler, _EnumRules_OneofSizer, []interface{}{
		(*EnumRules_Random)(nil),
		(*EnumRules_First)(nil),
		(*EnumRules_Last)(nil),
		(*EnumRules_Index)(nil),
		(*EnumRules_Value)(nil),
		(*EnumRules_RandomNoEmpty)(nil),
	}
}

func _EnumRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EnumRules)
	// type
	switch x := m.Type.(type) {
	case *EnumRules_Random:
		t := uint64(0)
		if x.Random {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *EnumRules_First:
		t := uint64(0)
		if x.First {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *EnumRules_Last:
		t := uint64(0)
		if x.Last {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *EnumRules_Index:
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Index))
	case *EnumRules_Value:
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Value))
	case *EnumRules_RandomNoEmpty:
		t := uint64(0)
		if x.RandomNoEmpty {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("EnumRules.Type has unexpected type %T", x)
	}
	return nil
}

func _EnumRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EnumRules)
	switch tag {
	case 2: // type.random
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &EnumRules_Random{x != 0}
		return true, err
	case 3: // type.first
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &EnumRules_First{x != 0}
		return true, err
	case 4: // type.last
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &EnumRules_Last{x != 0}
		return true, err
	case 5: // type.index
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &EnumRules_Index{uint32(x)}
		return true, err
	case 6: // type.value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &EnumRules_Value{uint32(x)}
		return true, err
	case 7: // type.random_no_empty
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &EnumRules_RandomNoEmpty{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _EnumRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EnumRules)
	// type
	switch x := m.Type.(type) {
	case *EnumRules_Random:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *EnumRules_First:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *EnumRules_Last:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *EnumRules_Index:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Index))
	case *EnumRules_Value:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Value))
	case *EnumRules_RandomNoEmpty:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AddressRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*AddressRules_City
	//	*AddressRules_StreetName
	//	*AddressRules_StreetAddress
	//	*AddressRules_SecondaryAddress
	//	*AddressRules_BuildingNumber
	//	*AddressRules_Postcode
	//	*AddressRules_PostcodeByState
	//	*AddressRules_ZipCode
	//	*AddressRules_ZipCodeByState
	//	*AddressRules_TimeZone
	//	*AddressRules_CityPrefix
	//	*AddressRules_CitySuffix
	//	*AddressRules_StreetSuffix
	//	*AddressRules_State
	//	*AddressRules_StateAbbr
	//	*AddressRules_Country
	//	*AddressRules_CountryCode
	//	*AddressRules_Latitude
	//	*AddressRules_Longitude
	//	*AddressRules_String_
	Type             isAddressRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *AddressRules) Reset()                    { *m = AddressRules{} }
func (m *AddressRules) String() string            { return proto.CompactTextString(m) }
func (*AddressRules) ProtoMessage()               {}
func (*AddressRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{4} }

type isAddressRules_Type interface {
	isAddressRules_Type()
}

type AddressRules_City struct {
	City bool `protobuf:"varint,2,opt,name=city,oneof"`
}
type AddressRules_StreetName struct {
	StreetName bool `protobuf:"varint,3,opt,name=street_name,json=streetName,oneof"`
}
type AddressRules_StreetAddress struct {
	StreetAddress bool `protobuf:"varint,4,opt,name=street_address,json=streetAddress,oneof"`
}
type AddressRules_SecondaryAddress struct {
	SecondaryAddress bool `protobuf:"varint,5,opt,name=secondary_address,json=secondaryAddress,oneof"`
}
type AddressRules_BuildingNumber struct {
	BuildingNumber bool `protobuf:"varint,6,opt,name=building_number,json=buildingNumber,oneof"`
}
type AddressRules_Postcode struct {
	Postcode bool `protobuf:"varint,7,opt,name=postcode,oneof"`
}
type AddressRules_PostcodeByState struct {
	PostcodeByState *AddressRulesByState `protobuf:"bytes,8,opt,name=postcode_by_state,json=postcodeByState,oneof"`
}
type AddressRules_ZipCode struct {
	ZipCode bool `protobuf:"varint,9,opt,name=zip_code,json=zipCode,oneof"`
}
type AddressRules_ZipCodeByState struct {
	ZipCodeByState *AddressRulesByState `protobuf:"bytes,10,opt,name=zip_code_by_state,json=zipCodeByState,oneof"`
}
type AddressRules_TimeZone struct {
	TimeZone bool `protobuf:"varint,11,opt,name=time_zone,json=timeZone,oneof"`
}
type AddressRules_CityPrefix struct {
	CityPrefix bool `protobuf:"varint,12,opt,name=city_prefix,json=cityPrefix,oneof"`
}
type AddressRules_CitySuffix struct {
	CitySuffix bool `protobuf:"varint,13,opt,name=city_suffix,json=citySuffix,oneof"`
}
type AddressRules_StreetSuffix struct {
	StreetSuffix bool `protobuf:"varint,14,opt,name=street_suffix,json=streetSuffix,oneof"`
}
type AddressRules_State struct {
	State bool `protobuf:"varint,15,opt,name=state,oneof"`
}
type AddressRules_StateAbbr struct {
	StateAbbr bool `protobuf:"varint,16,opt,name=state_abbr,json=stateAbbr,oneof"`
}
type AddressRules_Country struct {
	Country bool `protobuf:"varint,17,opt,name=country,oneof"`
}
type AddressRules_CountryCode struct {
	CountryCode bool `protobuf:"varint,18,opt,name=country_code,json=countryCode,oneof"`
}
type AddressRules_Latitude struct {
	Latitude bool `protobuf:"varint,19,opt,name=latitude,oneof"`
}
type AddressRules_Longitude struct {
	Longitude bool `protobuf:"varint,20,opt,name=longitude,oneof"`
}
type AddressRules_String_ struct {
	String_ bool `protobuf:"varint,21,opt,name=string,oneof"`
}

func (*AddressRules_City) isAddressRules_Type()             {}
func (*AddressRules_StreetName) isAddressRules_Type()       {}
func (*AddressRules_StreetAddress) isAddressRules_Type()    {}
func (*AddressRules_SecondaryAddress) isAddressRules_Type() {}
func (*AddressRules_BuildingNumber) isAddressRules_Type()   {}
func (*AddressRules_Postcode) isAddressRules_Type()         {}
func (*AddressRules_PostcodeByState) isAddressRules_Type()  {}
func (*AddressRules_ZipCode) isAddressRules_Type()          {}
func (*AddressRules_ZipCodeByState) isAddressRules_Type()   {}
func (*AddressRules_TimeZone) isAddressRules_Type()         {}
func (*AddressRules_CityPrefix) isAddressRules_Type()       {}
func (*AddressRules_CitySuffix) isAddressRules_Type()       {}
func (*AddressRules_StreetSuffix) isAddressRules_Type()     {}
func (*AddressRules_State) isAddressRules_Type()            {}
func (*AddressRules_StateAbbr) isAddressRules_Type()        {}
func (*AddressRules_Country) isAddressRules_Type()          {}
func (*AddressRules_CountryCode) isAddressRules_Type()      {}
func (*AddressRules_Latitude) isAddressRules_Type()         {}
func (*AddressRules_Longitude) isAddressRules_Type()        {}
func (*AddressRules_String_) isAddressRules_Type()          {}

func (m *AddressRules) GetType() isAddressRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *AddressRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *AddressRules) GetCity() bool {
	if x, ok := m.GetType().(*AddressRules_City); ok {
		return x.City
	}
	return false
}

func (m *AddressRules) GetStreetName() bool {
	if x, ok := m.GetType().(*AddressRules_StreetName); ok {
		return x.StreetName
	}
	return false
}

func (m *AddressRules) GetStreetAddress() bool {
	if x, ok := m.GetType().(*AddressRules_StreetAddress); ok {
		return x.StreetAddress
	}
	return false
}

func (m *AddressRules) GetSecondaryAddress() bool {
	if x, ok := m.GetType().(*AddressRules_SecondaryAddress); ok {
		return x.SecondaryAddress
	}
	return false
}

func (m *AddressRules) GetBuildingNumber() bool {
	if x, ok := m.GetType().(*AddressRules_BuildingNumber); ok {
		return x.BuildingNumber
	}
	return false
}

func (m *AddressRules) GetPostcode() bool {
	if x, ok := m.GetType().(*AddressRules_Postcode); ok {
		return x.Postcode
	}
	return false
}

func (m *AddressRules) GetPostcodeByState() *AddressRulesByState {
	if x, ok := m.GetType().(*AddressRules_PostcodeByState); ok {
		return x.PostcodeByState
	}
	return nil
}

func (m *AddressRules) GetZipCode() bool {
	if x, ok := m.GetType().(*AddressRules_ZipCode); ok {
		return x.ZipCode
	}
	return false
}

func (m *AddressRules) GetZipCodeByState() *AddressRulesByState {
	if x, ok := m.GetType().(*AddressRules_ZipCodeByState); ok {
		return x.ZipCodeByState
	}
	return nil
}

func (m *AddressRules) GetTimeZone() bool {
	if x, ok := m.GetType().(*AddressRules_TimeZone); ok {
		return x.TimeZone
	}
	return false
}

func (m *AddressRules) GetCityPrefix() bool {
	if x, ok := m.GetType().(*AddressRules_CityPrefix); ok {
		return x.CityPrefix
	}
	return false
}

func (m *AddressRules) GetCitySuffix() bool {
	if x, ok := m.GetType().(*AddressRules_CitySuffix); ok {
		return x.CitySuffix
	}
	return false
}

func (m *AddressRules) GetStreetSuffix() bool {
	if x, ok := m.GetType().(*AddressRules_StreetSuffix); ok {
		return x.StreetSuffix
	}
	return false
}

func (m *AddressRules) GetState() bool {
	if x, ok := m.GetType().(*AddressRules_State); ok {
		return x.State
	}
	return false
}

func (m *AddressRules) GetStateAbbr() bool {
	if x, ok := m.GetType().(*AddressRules_StateAbbr); ok {
		return x.StateAbbr
	}
	return false
}

func (m *AddressRules) GetCountry() bool {
	if x, ok := m.GetType().(*AddressRules_Country); ok {
		return x.Country
	}
	return false
}

func (m *AddressRules) GetCountryCode() bool {
	if x, ok := m.GetType().(*AddressRules_CountryCode); ok {
		return x.CountryCode
	}
	return false
}

func (m *AddressRules) GetLatitude() bool {
	if x, ok := m.GetType().(*AddressRules_Latitude); ok {
		return x.Latitude
	}
	return false
}

func (m *AddressRules) GetLongitude() bool {
	if x, ok := m.GetType().(*AddressRules_Longitude); ok {
		return x.Longitude
	}
	return false
}

func (m *AddressRules) GetString_() bool {
	if x, ok := m.GetType().(*AddressRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AddressRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AddressRules_OneofMarshaler, _AddressRules_OneofUnmarshaler, _AddressRules_OneofSizer, []interface{}{
		(*AddressRules_City)(nil),
		(*AddressRules_StreetName)(nil),
		(*AddressRules_StreetAddress)(nil),
		(*AddressRules_SecondaryAddress)(nil),
		(*AddressRules_BuildingNumber)(nil),
		(*AddressRules_Postcode)(nil),
		(*AddressRules_PostcodeByState)(nil),
		(*AddressRules_ZipCode)(nil),
		(*AddressRules_ZipCodeByState)(nil),
		(*AddressRules_TimeZone)(nil),
		(*AddressRules_CityPrefix)(nil),
		(*AddressRules_CitySuffix)(nil),
		(*AddressRules_StreetSuffix)(nil),
		(*AddressRules_State)(nil),
		(*AddressRules_StateAbbr)(nil),
		(*AddressRules_Country)(nil),
		(*AddressRules_CountryCode)(nil),
		(*AddressRules_Latitude)(nil),
		(*AddressRules_Longitude)(nil),
		(*AddressRules_String_)(nil),
	}
}

func _AddressRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AddressRules)
	// type
	switch x := m.Type.(type) {
	case *AddressRules_City:
		t := uint64(0)
		if x.City {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_StreetName:
		t := uint64(0)
		if x.StreetName {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_StreetAddress:
		t := uint64(0)
		if x.StreetAddress {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_SecondaryAddress:
		t := uint64(0)
		if x.SecondaryAddress {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_BuildingNumber:
		t := uint64(0)
		if x.BuildingNumber {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_Postcode:
		t := uint64(0)
		if x.Postcode {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_PostcodeByState:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PostcodeByState); err != nil {
			return err
		}
	case *AddressRules_ZipCode:
		t := uint64(0)
		if x.ZipCode {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_ZipCodeByState:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ZipCodeByState); err != nil {
			return err
		}
	case *AddressRules_TimeZone:
		t := uint64(0)
		if x.TimeZone {
			t = 1
		}
		_ = b.EncodeVarint(11<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_CityPrefix:
		t := uint64(0)
		if x.CityPrefix {
			t = 1
		}
		_ = b.EncodeVarint(12<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_CitySuffix:
		t := uint64(0)
		if x.CitySuffix {
			t = 1
		}
		_ = b.EncodeVarint(13<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_StreetSuffix:
		t := uint64(0)
		if x.StreetSuffix {
			t = 1
		}
		_ = b.EncodeVarint(14<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_State:
		t := uint64(0)
		if x.State {
			t = 1
		}
		_ = b.EncodeVarint(15<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_StateAbbr:
		t := uint64(0)
		if x.StateAbbr {
			t = 1
		}
		_ = b.EncodeVarint(16<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_Country:
		t := uint64(0)
		if x.Country {
			t = 1
		}
		_ = b.EncodeVarint(17<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_CountryCode:
		t := uint64(0)
		if x.CountryCode {
			t = 1
		}
		_ = b.EncodeVarint(18<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_Latitude:
		t := uint64(0)
		if x.Latitude {
			t = 1
		}
		_ = b.EncodeVarint(19<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_Longitude:
		t := uint64(0)
		if x.Longitude {
			t = 1
		}
		_ = b.EncodeVarint(20<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AddressRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(21<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("AddressRules.Type has unexpected type %T", x)
	}
	return nil
}

func _AddressRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AddressRules)
	switch tag {
	case 2: // type.city
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_City{x != 0}
		return true, err
	case 3: // type.street_name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_StreetName{x != 0}
		return true, err
	case 4: // type.street_address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_StreetAddress{x != 0}
		return true, err
	case 5: // type.secondary_address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_SecondaryAddress{x != 0}
		return true, err
	case 6: // type.building_number
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_BuildingNumber{x != 0}
		return true, err
	case 7: // type.postcode
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_Postcode{x != 0}
		return true, err
	case 8: // type.postcode_by_state
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRulesByState)
		err := b.DecodeMessage(msg)
		m.Type = &AddressRules_PostcodeByState{msg}
		return true, err
	case 9: // type.zip_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_ZipCode{x != 0}
		return true, err
	case 10: // type.zip_code_by_state
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressRulesByState)
		err := b.DecodeMessage(msg)
		m.Type = &AddressRules_ZipCodeByState{msg}
		return true, err
	case 11: // type.time_zone
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_TimeZone{x != 0}
		return true, err
	case 12: // type.city_prefix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_CityPrefix{x != 0}
		return true, err
	case 13: // type.city_suffix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_CitySuffix{x != 0}
		return true, err
	case 14: // type.street_suffix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_StreetSuffix{x != 0}
		return true, err
	case 15: // type.state
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_State{x != 0}
		return true, err
	case 16: // type.state_abbr
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_StateAbbr{x != 0}
		return true, err
	case 17: // type.country
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_Country{x != 0}
		return true, err
	case 18: // type.country_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_CountryCode{x != 0}
		return true, err
	case 19: // type.latitude
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_Latitude{x != 0}
		return true, err
	case 20: // type.longitude
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_Longitude{x != 0}
		return true, err
	case 21: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AddressRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _AddressRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AddressRules)
	// type
	switch x := m.Type.(type) {
	case *AddressRules_City:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_StreetName:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_StreetAddress:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_SecondaryAddress:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_BuildingNumber:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_Postcode:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_PostcodeByState:
		s := proto.Size(x.PostcodeByState)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AddressRules_ZipCode:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_ZipCodeByState:
		s := proto.Size(x.ZipCodeByState)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AddressRules_TimeZone:
		n += proto.SizeVarint(11<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_CityPrefix:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_CitySuffix:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_StreetSuffix:
		n += proto.SizeVarint(14<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_State:
		n += proto.SizeVarint(15<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_StateAbbr:
		n += proto.SizeVarint(16<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_Country:
		n += proto.SizeVarint(17<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_CountryCode:
		n += proto.SizeVarint(18<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_Latitude:
		n += proto.SizeVarint(19<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_Longitude:
		n += proto.SizeVarint(20<<3 | proto.WireVarint)
		n += 1
	case *AddressRules_String_:
		n += proto.SizeVarint(21<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AddressRulesByState struct {
	State            *string `protobuf:"bytes,1,req,name=state" json:"state,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AddressRulesByState) Reset()                    { *m = AddressRulesByState{} }
func (m *AddressRulesByState) String() string            { return proto.CompactTextString(m) }
func (*AddressRulesByState) ProtoMessage()               {}
func (*AddressRulesByState) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{5} }

func (m *AddressRulesByState) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

type AppRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*AppRules_Name
	//	*AppRules_Version
	//	*AppRules_Author
	//	*AppRules_String_
	Type             isAppRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *AppRules) Reset()                    { *m = AppRules{} }
func (m *AppRules) String() string            { return proto.CompactTextString(m) }
func (*AppRules) ProtoMessage()               {}
func (*AppRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{6} }

type isAppRules_Type interface {
	isAppRules_Type()
}

type AppRules_Name struct {
	Name bool `protobuf:"varint,2,opt,name=name,oneof"`
}
type AppRules_Version struct {
	Version bool `protobuf:"varint,3,opt,name=version,oneof"`
}
type AppRules_Author struct {
	Author bool `protobuf:"varint,4,opt,name=author,oneof"`
}
type AppRules_String_ struct {
	String_ bool `protobuf:"varint,5,opt,name=string,oneof"`
}

func (*AppRules_Name) isAppRules_Type()    {}
func (*AppRules_Version) isAppRules_Type() {}
func (*AppRules_Author) isAppRules_Type()  {}
func (*AppRules_String_) isAppRules_Type() {}

func (m *AppRules) GetType() isAppRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *AppRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *AppRules) GetName() bool {
	if x, ok := m.GetType().(*AppRules_Name); ok {
		return x.Name
	}
	return false
}

func (m *AppRules) GetVersion() bool {
	if x, ok := m.GetType().(*AppRules_Version); ok {
		return x.Version
	}
	return false
}

func (m *AppRules) GetAuthor() bool {
	if x, ok := m.GetType().(*AppRules_Author); ok {
		return x.Author
	}
	return false
}

func (m *AppRules) GetString_() bool {
	if x, ok := m.GetType().(*AppRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AppRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AppRules_OneofMarshaler, _AppRules_OneofUnmarshaler, _AppRules_OneofSizer, []interface{}{
		(*AppRules_Name)(nil),
		(*AppRules_Version)(nil),
		(*AppRules_Author)(nil),
		(*AppRules_String_)(nil),
	}
}

func _AppRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AppRules)
	// type
	switch x := m.Type.(type) {
	case *AppRules_Name:
		t := uint64(0)
		if x.Name {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AppRules_Version:
		t := uint64(0)
		if x.Version {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AppRules_Author:
		t := uint64(0)
		if x.Author {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AppRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("AppRules.Type has unexpected type %T", x)
	}
	return nil
}

func _AppRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AppRules)
	switch tag {
	case 2: // type.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AppRules_Name{x != 0}
		return true, err
	case 3: // type.version
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AppRules_Version{x != 0}
		return true, err
	case 4: // type.author
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AppRules_Author{x != 0}
		return true, err
	case 5: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AppRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _AppRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AppRules)
	// type
	switch x := m.Type.(type) {
	case *AppRules_Name:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *AppRules_Version:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *AppRules_Author:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *AppRules_String_:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AvatarRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*AvatarRules_Url
	//	*AvatarRules_String_
	Type             isAvatarRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *AvatarRules) Reset()                    { *m = AvatarRules{} }
func (m *AvatarRules) String() string            { return proto.CompactTextString(m) }
func (*AvatarRules) ProtoMessage()               {}
func (*AvatarRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{7} }

type isAvatarRules_Type interface {
	isAvatarRules_Type()
}

type AvatarRules_Url struct {
	Url *AvatarUrlRules `protobuf:"bytes,2,opt,name=url,oneof"`
}
type AvatarRules_String_ struct {
	String_ bool `protobuf:"varint,3,opt,name=string,oneof"`
}

func (*AvatarRules_Url) isAvatarRules_Type()     {}
func (*AvatarRules_String_) isAvatarRules_Type() {}

func (m *AvatarRules) GetType() isAvatarRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *AvatarRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *AvatarRules) GetUrl() *AvatarUrlRules {
	if x, ok := m.GetType().(*AvatarRules_Url); ok {
		return x.Url
	}
	return nil
}

func (m *AvatarRules) GetString_() bool {
	if x, ok := m.GetType().(*AvatarRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AvatarRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AvatarRules_OneofMarshaler, _AvatarRules_OneofUnmarshaler, _AvatarRules_OneofSizer, []interface{}{
		(*AvatarRules_Url)(nil),
		(*AvatarRules_String_)(nil),
	}
}

func _AvatarRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AvatarRules)
	// type
	switch x := m.Type.(type) {
	case *AvatarRules_Url:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Url); err != nil {
			return err
		}
	case *AvatarRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("AvatarRules.Type has unexpected type %T", x)
	}
	return nil
}

func _AvatarRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AvatarRules)
	switch tag {
	case 2: // type.url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AvatarUrlRules)
		err := b.DecodeMessage(msg)
		m.Type = &AvatarRules_Url{msg}
		return true, err
	case 3: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &AvatarRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _AvatarRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AvatarRules)
	// type
	switch x := m.Type.(type) {
	case *AvatarRules_Url:
		s := proto.Size(x.Url)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AvatarRules_String_:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AvatarUrlRules struct {
	Format           *string `protobuf:"bytes,1,req,name=format" json:"format,omitempty"`
	Width            *uint64 `protobuf:"varint,2,req,name=width" json:"width,omitempty"`
	Height           *uint64 `protobuf:"varint,3,req,name=height" json:"height,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AvatarUrlRules) Reset()                    { *m = AvatarUrlRules{} }
func (m *AvatarUrlRules) String() string            { return proto.CompactTextString(m) }
func (*AvatarUrlRules) ProtoMessage()               {}
func (*AvatarUrlRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{8} }

func (m *AvatarUrlRules) GetFormat() string {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return ""
}

func (m *AvatarUrlRules) GetWidth() uint64 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

func (m *AvatarUrlRules) GetHeight() uint64 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

type BitcoinRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*BitcoinRules_Address
	//	*BitcoinRules_String_
	Type             isBitcoinRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *BitcoinRules) Reset()                    { *m = BitcoinRules{} }
func (m *BitcoinRules) String() string            { return proto.CompactTextString(m) }
func (*BitcoinRules) ProtoMessage()               {}
func (*BitcoinRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{9} }

type isBitcoinRules_Type interface {
	isBitcoinRules_Type()
}

type BitcoinRules_Address struct {
	Address bool `protobuf:"varint,2,opt,name=address,oneof"`
}
type BitcoinRules_String_ struct {
	String_ bool `protobuf:"varint,3,opt,name=string,oneof"`
}

func (*BitcoinRules_Address) isBitcoinRules_Type() {}
func (*BitcoinRules_String_) isBitcoinRules_Type() {}

func (m *BitcoinRules) GetType() isBitcoinRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *BitcoinRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *BitcoinRules) GetAddress() bool {
	if x, ok := m.GetType().(*BitcoinRules_Address); ok {
		return x.Address
	}
	return false
}

func (m *BitcoinRules) GetString_() bool {
	if x, ok := m.GetType().(*BitcoinRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BitcoinRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BitcoinRules_OneofMarshaler, _BitcoinRules_OneofUnmarshaler, _BitcoinRules_OneofSizer, []interface{}{
		(*BitcoinRules_Address)(nil),
		(*BitcoinRules_String_)(nil),
	}
}

func _BitcoinRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BitcoinRules)
	// type
	switch x := m.Type.(type) {
	case *BitcoinRules_Address:
		t := uint64(0)
		if x.Address {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *BitcoinRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("BitcoinRules.Type has unexpected type %T", x)
	}
	return nil
}

func _BitcoinRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BitcoinRules)
	switch tag {
	case 2: // type.address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &BitcoinRules_Address{x != 0}
		return true, err
	case 3: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &BitcoinRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _BitcoinRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BitcoinRules)
	// type
	switch x := m.Type.(type) {
	case *BitcoinRules_Address:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *BitcoinRules_String_:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BusinessRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*BusinessRules_CreditCardNumber
	//	*BusinessRules_CreditCardExpiryDate
	//	*BusinessRules_CreditCardType
	Type             isBusinessRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *BusinessRules) Reset()                    { *m = BusinessRules{} }
func (m *BusinessRules) String() string            { return proto.CompactTextString(m) }
func (*BusinessRules) ProtoMessage()               {}
func (*BusinessRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{10} }

type isBusinessRules_Type interface {
	isBusinessRules_Type()
}

type BusinessRules_CreditCardNumber struct {
	CreditCardNumber bool `protobuf:"varint,2,opt,name=credit_card_number,json=creditCardNumber,oneof"`
}
type BusinessRules_CreditCardExpiryDate struct {
	CreditCardExpiryDate bool `protobuf:"varint,3,opt,name=credit_card_expiry_date,json=creditCardExpiryDate,oneof"`
}
type BusinessRules_CreditCardType struct {
	CreditCardType bool `protobuf:"varint,4,opt,name=credit_card_type,json=creditCardType,oneof"`
}

func (*BusinessRules_CreditCardNumber) isBusinessRules_Type()     {}
func (*BusinessRules_CreditCardExpiryDate) isBusinessRules_Type() {}
func (*BusinessRules_CreditCardType) isBusinessRules_Type()       {}

func (m *BusinessRules) GetType() isBusinessRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *BusinessRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *BusinessRules) GetCreditCardNumber() bool {
	if x, ok := m.GetType().(*BusinessRules_CreditCardNumber); ok {
		return x.CreditCardNumber
	}
	return false
}

func (m *BusinessRules) GetCreditCardExpiryDate() bool {
	if x, ok := m.GetType().(*BusinessRules_CreditCardExpiryDate); ok {
		return x.CreditCardExpiryDate
	}
	return false
}

func (m *BusinessRules) GetCreditCardType() bool {
	if x, ok := m.GetType().(*BusinessRules_CreditCardType); ok {
		return x.CreditCardType
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BusinessRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BusinessRules_OneofMarshaler, _BusinessRules_OneofUnmarshaler, _BusinessRules_OneofSizer, []interface{}{
		(*BusinessRules_CreditCardNumber)(nil),
		(*BusinessRules_CreditCardExpiryDate)(nil),
		(*BusinessRules_CreditCardType)(nil),
	}
}

func _BusinessRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BusinessRules)
	// type
	switch x := m.Type.(type) {
	case *BusinessRules_CreditCardNumber:
		t := uint64(0)
		if x.CreditCardNumber {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *BusinessRules_CreditCardExpiryDate:
		t := uint64(0)
		if x.CreditCardExpiryDate {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *BusinessRules_CreditCardType:
		t := uint64(0)
		if x.CreditCardType {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("BusinessRules.Type has unexpected type %T", x)
	}
	return nil
}

func _BusinessRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BusinessRules)
	switch tag {
	case 2: // type.credit_card_number
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &BusinessRules_CreditCardNumber{x != 0}
		return true, err
	case 3: // type.credit_card_expiry_date
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &BusinessRules_CreditCardExpiryDate{x != 0}
		return true, err
	case 4: // type.credit_card_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &BusinessRules_CreditCardType{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _BusinessRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BusinessRules)
	// type
	switch x := m.Type.(type) {
	case *BusinessRules_CreditCardNumber:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *BusinessRules_CreditCardExpiryDate:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *BusinessRules_CreditCardType:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CodeRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*CodeRules_Isbn10
	//	*CodeRules_Isbn13
	//	*CodeRules_Ean13
	//	*CodeRules_Ean8
	//	*CodeRules_Rut
	//	*CodeRules_Abn
	Type             isCodeRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *CodeRules) Reset()                    { *m = CodeRules{} }
func (m *CodeRules) String() string            { return proto.CompactTextString(m) }
func (*CodeRules) ProtoMessage()               {}
func (*CodeRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{11} }

type isCodeRules_Type interface {
	isCodeRules_Type()
}

type CodeRules_Isbn10 struct {
	Isbn10 bool `protobuf:"varint,2,opt,name=isbn10,oneof"`
}
type CodeRules_Isbn13 struct {
	Isbn13 bool `protobuf:"varint,3,opt,name=isbn13,oneof"`
}
type CodeRules_Ean13 struct {
	Ean13 bool `protobuf:"varint,4,opt,name=ean13,oneof"`
}
type CodeRules_Ean8 struct {
	Ean8 bool `protobuf:"varint,5,opt,name=ean8,oneof"`
}
type CodeRules_Rut struct {
	Rut bool `protobuf:"varint,6,opt,name=rut,oneof"`
}
type CodeRules_Abn struct {
	Abn bool `protobuf:"varint,7,opt,name=abn,oneof"`
}

func (*CodeRules_Isbn10) isCodeRules_Type() {}
func (*CodeRules_Isbn13) isCodeRules_Type() {}
func (*CodeRules_Ean13) isCodeRules_Type()  {}
func (*CodeRules_Ean8) isCodeRules_Type()   {}
func (*CodeRules_Rut) isCodeRules_Type()    {}
func (*CodeRules_Abn) isCodeRules_Type()    {}

func (m *CodeRules) GetType() isCodeRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CodeRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *CodeRules) GetIsbn10() bool {
	if x, ok := m.GetType().(*CodeRules_Isbn10); ok {
		return x.Isbn10
	}
	return false
}

func (m *CodeRules) GetIsbn13() bool {
	if x, ok := m.GetType().(*CodeRules_Isbn13); ok {
		return x.Isbn13
	}
	return false
}

func (m *CodeRules) GetEan13() bool {
	if x, ok := m.GetType().(*CodeRules_Ean13); ok {
		return x.Ean13
	}
	return false
}

func (m *CodeRules) GetEan8() bool {
	if x, ok := m.GetType().(*CodeRules_Ean8); ok {
		return x.Ean8
	}
	return false
}

func (m *CodeRules) GetRut() bool {
	if x, ok := m.GetType().(*CodeRules_Rut); ok {
		return x.Rut
	}
	return false
}

func (m *CodeRules) GetAbn() bool {
	if x, ok := m.GetType().(*CodeRules_Abn); ok {
		return x.Abn
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CodeRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CodeRules_OneofMarshaler, _CodeRules_OneofUnmarshaler, _CodeRules_OneofSizer, []interface{}{
		(*CodeRules_Isbn10)(nil),
		(*CodeRules_Isbn13)(nil),
		(*CodeRules_Ean13)(nil),
		(*CodeRules_Ean8)(nil),
		(*CodeRules_Rut)(nil),
		(*CodeRules_Abn)(nil),
	}
}

func _CodeRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CodeRules)
	// type
	switch x := m.Type.(type) {
	case *CodeRules_Isbn10:
		t := uint64(0)
		if x.Isbn10 {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CodeRules_Isbn13:
		t := uint64(0)
		if x.Isbn13 {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CodeRules_Ean13:
		t := uint64(0)
		if x.Ean13 {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CodeRules_Ean8:
		t := uint64(0)
		if x.Ean8 {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CodeRules_Rut:
		t := uint64(0)
		if x.Rut {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CodeRules_Abn:
		t := uint64(0)
		if x.Abn {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("CodeRules.Type has unexpected type %T", x)
	}
	return nil
}

func _CodeRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CodeRules)
	switch tag {
	case 2: // type.isbn10
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CodeRules_Isbn10{x != 0}
		return true, err
	case 3: // type.isbn13
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CodeRules_Isbn13{x != 0}
		return true, err
	case 4: // type.ean13
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CodeRules_Ean13{x != 0}
		return true, err
	case 5: // type.ean8
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CodeRules_Ean8{x != 0}
		return true, err
	case 6: // type.rut
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CodeRules_Rut{x != 0}
		return true, err
	case 7: // type.abn
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CodeRules_Abn{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _CodeRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CodeRules)
	// type
	switch x := m.Type.(type) {
	case *CodeRules_Isbn10:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *CodeRules_Isbn13:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *CodeRules_Ean13:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *CodeRules_Ean8:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *CodeRules_Rut:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case *CodeRules_Abn:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommerceRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*CommerceRules_Color
	//	*CommerceRules_Department
	//	*CommerceRules_ProductName
	//	*CommerceRules_Price
	Type             isCommerceRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *CommerceRules) Reset()                    { *m = CommerceRules{} }
func (m *CommerceRules) String() string            { return proto.CompactTextString(m) }
func (*CommerceRules) ProtoMessage()               {}
func (*CommerceRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{12} }

type isCommerceRules_Type interface {
	isCommerceRules_Type()
}

type CommerceRules_Color struct {
	Color bool `protobuf:"varint,2,opt,name=color,oneof"`
}
type CommerceRules_Department struct {
	Department bool `protobuf:"varint,3,opt,name=department,oneof"`
}
type CommerceRules_ProductName struct {
	ProductName bool `protobuf:"varint,4,opt,name=product_name,json=productName,oneof"`
}
type CommerceRules_Price struct {
	Price bool `protobuf:"varint,5,opt,name=price,oneof"`
}

func (*CommerceRules_Color) isCommerceRules_Type()       {}
func (*CommerceRules_Department) isCommerceRules_Type()  {}
func (*CommerceRules_ProductName) isCommerceRules_Type() {}
func (*CommerceRules_Price) isCommerceRules_Type()       {}

func (m *CommerceRules) GetType() isCommerceRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CommerceRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *CommerceRules) GetColor() bool {
	if x, ok := m.GetType().(*CommerceRules_Color); ok {
		return x.Color
	}
	return false
}

func (m *CommerceRules) GetDepartment() bool {
	if x, ok := m.GetType().(*CommerceRules_Department); ok {
		return x.Department
	}
	return false
}

func (m *CommerceRules) GetProductName() bool {
	if x, ok := m.GetType().(*CommerceRules_ProductName); ok {
		return x.ProductName
	}
	return false
}

func (m *CommerceRules) GetPrice() bool {
	if x, ok := m.GetType().(*CommerceRules_Price); ok {
		return x.Price
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommerceRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommerceRules_OneofMarshaler, _CommerceRules_OneofUnmarshaler, _CommerceRules_OneofSizer, []interface{}{
		(*CommerceRules_Color)(nil),
		(*CommerceRules_Department)(nil),
		(*CommerceRules_ProductName)(nil),
		(*CommerceRules_Price)(nil),
	}
}

func _CommerceRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommerceRules)
	// type
	switch x := m.Type.(type) {
	case *CommerceRules_Color:
		t := uint64(0)
		if x.Color {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CommerceRules_Department:
		t := uint64(0)
		if x.Department {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CommerceRules_ProductName:
		t := uint64(0)
		if x.ProductName {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CommerceRules_Price:
		t := uint64(0)
		if x.Price {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("CommerceRules.Type has unexpected type %T", x)
	}
	return nil
}

func _CommerceRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommerceRules)
	switch tag {
	case 2: // type.color
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CommerceRules_Color{x != 0}
		return true, err
	case 3: // type.department
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CommerceRules_Department{x != 0}
		return true, err
	case 4: // type.product_name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CommerceRules_ProductName{x != 0}
		return true, err
	case 5: // type.price
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CommerceRules_Price{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _CommerceRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommerceRules)
	// type
	switch x := m.Type.(type) {
	case *CommerceRules_Color:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *CommerceRules_Department:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *CommerceRules_ProductName:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *CommerceRules_Price:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CompanyRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*CompanyRules_Name
	//	*CompanyRules_Suffix
	//	*CompanyRules_CatchPhrase
	//	*CompanyRules_Bs
	//	*CompanyRules_Ein
	//	*CompanyRules_DunsNumber
	//	*CompanyRules_Logo
	//	*CompanyRules_String_
	Type             isCompanyRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *CompanyRules) Reset()                    { *m = CompanyRules{} }
func (m *CompanyRules) String() string            { return proto.CompactTextString(m) }
func (*CompanyRules) ProtoMessage()               {}
func (*CompanyRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{13} }

type isCompanyRules_Type interface {
	isCompanyRules_Type()
}

type CompanyRules_Name struct {
	Name bool `protobuf:"varint,2,opt,name=name,oneof"`
}
type CompanyRules_Suffix struct {
	Suffix bool `protobuf:"varint,3,opt,name=suffix,oneof"`
}
type CompanyRules_CatchPhrase struct {
	CatchPhrase bool `protobuf:"varint,4,opt,name=catch_phrase,json=catchPhrase,oneof"`
}
type CompanyRules_Bs struct {
	Bs bool `protobuf:"varint,5,opt,name=bs,oneof"`
}
type CompanyRules_Ein struct {
	Ein bool `protobuf:"varint,6,opt,name=ein,oneof"`
}
type CompanyRules_DunsNumber struct {
	DunsNumber bool `protobuf:"varint,7,opt,name=duns_number,json=dunsNumber,oneof"`
}
type CompanyRules_Logo struct {
	Logo bool `protobuf:"varint,8,opt,name=logo,oneof"`
}
type CompanyRules_String_ struct {
	String_ bool `protobuf:"varint,9,opt,name=string,oneof"`
}

func (*CompanyRules_Name) isCompanyRules_Type()        {}
func (*CompanyRules_Suffix) isCompanyRules_Type()      {}
func (*CompanyRules_CatchPhrase) isCompanyRules_Type() {}
func (*CompanyRules_Bs) isCompanyRules_Type()          {}
func (*CompanyRules_Ein) isCompanyRules_Type()         {}
func (*CompanyRules_DunsNumber) isCompanyRules_Type()  {}
func (*CompanyRules_Logo) isCompanyRules_Type()        {}
func (*CompanyRules_String_) isCompanyRules_Type()     {}

func (m *CompanyRules) GetType() isCompanyRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CompanyRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *CompanyRules) GetName() bool {
	if x, ok := m.GetType().(*CompanyRules_Name); ok {
		return x.Name
	}
	return false
}

func (m *CompanyRules) GetSuffix() bool {
	if x, ok := m.GetType().(*CompanyRules_Suffix); ok {
		return x.Suffix
	}
	return false
}

func (m *CompanyRules) GetCatchPhrase() bool {
	if x, ok := m.GetType().(*CompanyRules_CatchPhrase); ok {
		return x.CatchPhrase
	}
	return false
}

func (m *CompanyRules) GetBs() bool {
	if x, ok := m.GetType().(*CompanyRules_Bs); ok {
		return x.Bs
	}
	return false
}

func (m *CompanyRules) GetEin() bool {
	if x, ok := m.GetType().(*CompanyRules_Ein); ok {
		return x.Ein
	}
	return false
}

func (m *CompanyRules) GetDunsNumber() bool {
	if x, ok := m.GetType().(*CompanyRules_DunsNumber); ok {
		return x.DunsNumber
	}
	return false
}

func (m *CompanyRules) GetLogo() bool {
	if x, ok := m.GetType().(*CompanyRules_Logo); ok {
		return x.Logo
	}
	return false
}

func (m *CompanyRules) GetString_() bool {
	if x, ok := m.GetType().(*CompanyRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CompanyRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CompanyRules_OneofMarshaler, _CompanyRules_OneofUnmarshaler, _CompanyRules_OneofSizer, []interface{}{
		(*CompanyRules_Name)(nil),
		(*CompanyRules_Suffix)(nil),
		(*CompanyRules_CatchPhrase)(nil),
		(*CompanyRules_Bs)(nil),
		(*CompanyRules_Ein)(nil),
		(*CompanyRules_DunsNumber)(nil),
		(*CompanyRules_Logo)(nil),
		(*CompanyRules_String_)(nil),
	}
}

func _CompanyRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CompanyRules)
	// type
	switch x := m.Type.(type) {
	case *CompanyRules_Name:
		t := uint64(0)
		if x.Name {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_Suffix:
		t := uint64(0)
		if x.Suffix {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_CatchPhrase:
		t := uint64(0)
		if x.CatchPhrase {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_Bs:
		t := uint64(0)
		if x.Bs {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_Ein:
		t := uint64(0)
		if x.Ein {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_DunsNumber:
		t := uint64(0)
		if x.DunsNumber {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_Logo:
		t := uint64(0)
		if x.Logo {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *CompanyRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("CompanyRules.Type has unexpected type %T", x)
	}
	return nil
}

func _CompanyRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CompanyRules)
	switch tag {
	case 2: // type.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_Name{x != 0}
		return true, err
	case 3: // type.suffix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_Suffix{x != 0}
		return true, err
	case 4: // type.catch_phrase
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_CatchPhrase{x != 0}
		return true, err
	case 5: // type.bs
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_Bs{x != 0}
		return true, err
	case 6: // type.ein
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_Ein{x != 0}
		return true, err
	case 7: // type.duns_number
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_DunsNumber{x != 0}
		return true, err
	case 8: // type.logo
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_Logo{x != 0}
		return true, err
	case 9: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CompanyRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _CompanyRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CompanyRules)
	// type
	switch x := m.Type.(type) {
	case *CompanyRules_Name:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_Suffix:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_CatchPhrase:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_Bs:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_Ein:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_DunsNumber:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_Logo:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case *CompanyRules_String_:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DateRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	Format   *string `protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*DateRules_Between
	//	*DateRules_Forward
	//	*DateRules_Backward
	//	*DateRules_Birthday
	//	*DateRules_Now
	Type             isDateRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *DateRules) Reset()                    { *m = DateRules{} }
func (m *DateRules) String() string            { return proto.CompactTextString(m) }
func (*DateRules) ProtoMessage()               {}
func (*DateRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{14} }

type isDateRules_Type interface {
	isDateRules_Type()
}

type DateRules_Between struct {
	Between *DateRulesBetween `protobuf:"bytes,3,opt,name=between,oneof"`
}
type DateRules_Forward struct {
	Forward string `protobuf:"bytes,4,opt,name=forward,oneof"`
}
type DateRules_Backward struct {
	Backward string `protobuf:"bytes,5,opt,name=backward,oneof"`
}
type DateRules_Birthday struct {
	Birthday *DateRulesBirthday `protobuf:"bytes,6,opt,name=birthday,oneof"`
}
type DateRules_Now struct {
	Now bool `protobuf:"varint,7,opt,name=now,oneof"`
}

func (*DateRules_Between) isDateRules_Type()  {}
func (*DateRules_Forward) isDateRules_Type()  {}
func (*DateRules_Backward) isDateRules_Type() {}
func (*DateRules_Birthday) isDateRules_Type() {}
func (*DateRules_Now) isDateRules_Type()      {}

func (m *DateRules) GetType() isDateRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DateRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *DateRules) GetFormat() string {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return ""
}

func (m *DateRules) GetBetween() *DateRulesBetween {
	if x, ok := m.GetType().(*DateRules_Between); ok {
		return x.Between
	}
	return nil
}

func (m *DateRules) GetForward() string {
	if x, ok := m.GetType().(*DateRules_Forward); ok {
		return x.Forward
	}
	return ""
}

func (m *DateRules) GetBackward() string {
	if x, ok := m.GetType().(*DateRules_Backward); ok {
		return x.Backward
	}
	return ""
}

func (m *DateRules) GetBirthday() *DateRulesBirthday {
	if x, ok := m.GetType().(*DateRules_Birthday); ok {
		return x.Birthday
	}
	return nil
}

func (m *DateRules) GetNow() bool {
	if x, ok := m.GetType().(*DateRules_Now); ok {
		return x.Now
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DateRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DateRules_OneofMarshaler, _DateRules_OneofUnmarshaler, _DateRules_OneofSizer, []interface{}{
		(*DateRules_Between)(nil),
		(*DateRules_Forward)(nil),
		(*DateRules_Backward)(nil),
		(*DateRules_Birthday)(nil),
		(*DateRules_Now)(nil),
	}
}

func _DateRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DateRules)
	// type
	switch x := m.Type.(type) {
	case *DateRules_Between:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Between); err != nil {
			return err
		}
	case *DateRules_Forward:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Forward)
	case *DateRules_Backward:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Backward)
	case *DateRules_Birthday:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Birthday); err != nil {
			return err
		}
	case *DateRules_Now:
		t := uint64(0)
		if x.Now {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("DateRules.Type has unexpected type %T", x)
	}
	return nil
}

func _DateRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DateRules)
	switch tag {
	case 3: // type.between
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DateRulesBetween)
		err := b.DecodeMessage(msg)
		m.Type = &DateRules_Between{msg}
		return true, err
	case 4: // type.forward
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &DateRules_Forward{x}
		return true, err
	case 5: // type.backward
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &DateRules_Backward{x}
		return true, err
	case 6: // type.birthday
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DateRulesBirthday)
		err := b.DecodeMessage(msg)
		m.Type = &DateRules_Birthday{msg}
		return true, err
	case 7: // type.now
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &DateRules_Now{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _DateRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DateRules)
	// type
	switch x := m.Type.(type) {
	case *DateRules_Between:
		s := proto.Size(x.Between)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DateRules_Forward:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Forward)))
		n += len(x.Forward)
	case *DateRules_Backward:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Backward)))
		n += len(x.Backward)
	case *DateRules_Birthday:
		s := proto.Size(x.Birthday)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DateRules_Now:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DateRulesBirthday struct {
	Min              *int32 `protobuf:"varint,1,req,name=min" json:"min,omitempty"`
	Max              *int32 `protobuf:"varint,2,req,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DateRulesBirthday) Reset()                    { *m = DateRulesBirthday{} }
func (m *DateRulesBirthday) String() string            { return proto.CompactTextString(m) }
func (*DateRulesBirthday) ProtoMessage()               {}
func (*DateRulesBirthday) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{15} }

func (m *DateRulesBirthday) GetMin() int32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *DateRulesBirthday) GetMax() int32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type DateRulesBetween struct {
	From             *string `protobuf:"bytes,1,req,name=from" json:"from,omitempty"`
	To               *string `protobuf:"bytes,2,req,name=to" json:"to,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DateRulesBetween) Reset()                    { *m = DateRulesBetween{} }
func (m *DateRulesBetween) String() string            { return proto.CompactTextString(m) }
func (*DateRulesBetween) ProtoMessage()               {}
func (*DateRulesBetween) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{16} }

func (m *DateRulesBetween) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *DateRulesBetween) GetTo() string {
	if m != nil && m.To != nil {
		return *m.To
	}
	return ""
}

type FinanceRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*FinanceRules_CreditCard
	Type             isFinanceRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *FinanceRules) Reset()                    { *m = FinanceRules{} }
func (m *FinanceRules) String() string            { return proto.CompactTextString(m) }
func (*FinanceRules) ProtoMessage()               {}
func (*FinanceRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{17} }

type isFinanceRules_Type interface {
	isFinanceRules_Type()
}

type FinanceRules_CreditCard struct {
	CreditCard *FinanceRulesCreditCard `protobuf:"bytes,2,opt,name=credit_card,json=creditCard,oneof"`
}

func (*FinanceRules_CreditCard) isFinanceRules_Type() {}

func (m *FinanceRules) GetType() isFinanceRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *FinanceRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *FinanceRules) GetCreditCard() *FinanceRulesCreditCard {
	if x, ok := m.GetType().(*FinanceRules_CreditCard); ok {
		return x.CreditCard
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FinanceRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FinanceRules_OneofMarshaler, _FinanceRules_OneofUnmarshaler, _FinanceRules_OneofSizer, []interface{}{
		(*FinanceRules_CreditCard)(nil),
	}
}

func _FinanceRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FinanceRules)
	// type
	switch x := m.Type.(type) {
	case *FinanceRules_CreditCard:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreditCard); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FinanceRules.Type has unexpected type %T", x)
	}
	return nil
}

func _FinanceRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FinanceRules)
	switch tag {
	case 2: // type.credit_card
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FinanceRulesCreditCard)
		err := b.DecodeMessage(msg)
		m.Type = &FinanceRules_CreditCard{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FinanceRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FinanceRules)
	// type
	switch x := m.Type.(type) {
	case *FinanceRules_CreditCard:
		s := proto.Size(x.CreditCard)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type FinanceRulesCreditCard struct {
	Type             *string `protobuf:"bytes,1,req,name=type" json:"type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FinanceRulesCreditCard) Reset()         { *m = FinanceRulesCreditCard{} }
func (m *FinanceRulesCreditCard) String() string { return proto.CompactTextString(m) }
func (*FinanceRulesCreditCard) ProtoMessage()    {}
func (*FinanceRulesCreditCard) Descriptor() ([]byte, []int) {
	return fileDescriptorGomeetfaker, []int{18}
}

func (m *FinanceRulesCreditCard) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

type HackerRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*HackerRules_SaySomethingSmart
	//	*HackerRules_Abbreviation
	//	*HackerRules_Adjective
	//	*HackerRules_Noun
	//	*HackerRules_Verb
	//	*HackerRules_IngVerb
	//	*HackerRules_Phrases
	Type             isHackerRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *HackerRules) Reset()                    { *m = HackerRules{} }
func (m *HackerRules) String() string            { return proto.CompactTextString(m) }
func (*HackerRules) ProtoMessage()               {}
func (*HackerRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{19} }

type isHackerRules_Type interface {
	isHackerRules_Type()
}

type HackerRules_SaySomethingSmart struct {
	SaySomethingSmart bool `protobuf:"varint,2,opt,name=say_something_smart,json=saySomethingSmart,oneof"`
}
type HackerRules_Abbreviation struct {
	Abbreviation bool `protobuf:"varint,3,opt,name=abbreviation,oneof"`
}
type HackerRules_Adjective struct {
	Adjective bool `protobuf:"varint,4,opt,name=adjective,oneof"`
}
type HackerRules_Noun struct {
	Noun bool `protobuf:"varint,5,opt,name=noun,oneof"`
}
type HackerRules_Verb struct {
	Verb bool `protobuf:"varint,6,opt,name=verb,oneof"`
}
type HackerRules_IngVerb struct {
	IngVerb bool `protobuf:"varint,7,opt,name=ing_verb,json=ingVerb,oneof"`
}
type HackerRules_Phrases struct {
	Phrases bool `protobuf:"varint,8,opt,name=phrases,oneof"`
}

func (*HackerRules_SaySomethingSmart) isHackerRules_Type() {}
func (*HackerRules_Abbreviation) isHackerRules_Type()      {}
func (*HackerRules_Adjective) isHackerRules_Type()         {}
func (*HackerRules_Noun) isHackerRules_Type()              {}
func (*HackerRules_Verb) isHackerRules_Type()              {}
func (*HackerRules_IngVerb) isHackerRules_Type()           {}
func (*HackerRules_Phrases) isHackerRules_Type()           {}

func (m *HackerRules) GetType() isHackerRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *HackerRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *HackerRules) GetSaySomethingSmart() bool {
	if x, ok := m.GetType().(*HackerRules_SaySomethingSmart); ok {
		return x.SaySomethingSmart
	}
	return false
}

func (m *HackerRules) GetAbbreviation() bool {
	if x, ok := m.GetType().(*HackerRules_Abbreviation); ok {
		return x.Abbreviation
	}
	return false
}

func (m *HackerRules) GetAdjective() bool {
	if x, ok := m.GetType().(*HackerRules_Adjective); ok {
		return x.Adjective
	}
	return false
}

func (m *HackerRules) GetNoun() bool {
	if x, ok := m.GetType().(*HackerRules_Noun); ok {
		return x.Noun
	}
	return false
}

func (m *HackerRules) GetVerb() bool {
	if x, ok := m.GetType().(*HackerRules_Verb); ok {
		return x.Verb
	}
	return false
}

func (m *HackerRules) GetIngVerb() bool {
	if x, ok := m.GetType().(*HackerRules_IngVerb); ok {
		return x.IngVerb
	}
	return false
}

func (m *HackerRules) GetPhrases() bool {
	if x, ok := m.GetType().(*HackerRules_Phrases); ok {
		return x.Phrases
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HackerRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HackerRules_OneofMarshaler, _HackerRules_OneofUnmarshaler, _HackerRules_OneofSizer, []interface{}{
		(*HackerRules_SaySomethingSmart)(nil),
		(*HackerRules_Abbreviation)(nil),
		(*HackerRules_Adjective)(nil),
		(*HackerRules_Noun)(nil),
		(*HackerRules_Verb)(nil),
		(*HackerRules_IngVerb)(nil),
		(*HackerRules_Phrases)(nil),
	}
}

func _HackerRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HackerRules)
	// type
	switch x := m.Type.(type) {
	case *HackerRules_SaySomethingSmart:
		t := uint64(0)
		if x.SaySomethingSmart {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HackerRules_Abbreviation:
		t := uint64(0)
		if x.Abbreviation {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HackerRules_Adjective:
		t := uint64(0)
		if x.Adjective {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HackerRules_Noun:
		t := uint64(0)
		if x.Noun {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HackerRules_Verb:
		t := uint64(0)
		if x.Verb {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HackerRules_IngVerb:
		t := uint64(0)
		if x.IngVerb {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HackerRules_Phrases:
		t := uint64(0)
		if x.Phrases {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("HackerRules.Type has unexpected type %T", x)
	}
	return nil
}

func _HackerRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HackerRules)
	switch tag {
	case 2: // type.say_something_smart
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_SaySomethingSmart{x != 0}
		return true, err
	case 3: // type.abbreviation
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_Abbreviation{x != 0}
		return true, err
	case 4: // type.adjective
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_Adjective{x != 0}
		return true, err
	case 5: // type.noun
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_Noun{x != 0}
		return true, err
	case 6: // type.verb
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_Verb{x != 0}
		return true, err
	case 7: // type.ing_verb
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_IngVerb{x != 0}
		return true, err
	case 8: // type.phrases
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &HackerRules_Phrases{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _HackerRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HackerRules)
	// type
	switch x := m.Type.(type) {
	case *HackerRules_SaySomethingSmart:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *HackerRules_Abbreviation:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *HackerRules_Adjective:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *HackerRules_Noun:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *HackerRules_Verb:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case *HackerRules_IngVerb:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *HackerRules_Phrases:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type InternetRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*InternetRules_Email
	//	*InternetRules_FreeEmail
	//	*InternetRules_SafeEmail
	//	*InternetRules_UserName
	//	*InternetRules_Password
	//	*InternetRules_DomainName
	//	*InternetRules_DomainWord
	//	*InternetRules_DomainSuffix
	//	*InternetRules_MacAddress
	//	*InternetRules_Ipv4Address
	//	*InternetRules_Ipv6Address
	//	*InternetRules_Url
	//	*InternetRules_Slug
	Type             isInternetRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *InternetRules) Reset()                    { *m = InternetRules{} }
func (m *InternetRules) String() string            { return proto.CompactTextString(m) }
func (*InternetRules) ProtoMessage()               {}
func (*InternetRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{20} }

type isInternetRules_Type interface {
	isInternetRules_Type()
}

type InternetRules_Email struct {
	Email bool `protobuf:"varint,2,opt,name=email,oneof"`
}
type InternetRules_FreeEmail struct {
	FreeEmail bool `protobuf:"varint,3,opt,name=free_email,json=freeEmail,oneof"`
}
type InternetRules_SafeEmail struct {
	SafeEmail bool `protobuf:"varint,4,opt,name=safe_email,json=safeEmail,oneof"`
}
type InternetRules_UserName struct {
	UserName bool `protobuf:"varint,5,opt,name=user_name,json=userName,oneof"`
}
type InternetRules_Password struct {
	Password *InternetRulesPassword `protobuf:"bytes,6,opt,name=password,oneof"`
}
type InternetRules_DomainName struct {
	DomainName bool `protobuf:"varint,7,opt,name=domain_name,json=domainName,oneof"`
}
type InternetRules_DomainWord struct {
	DomainWord bool `protobuf:"varint,8,opt,name=domain_word,json=domainWord,oneof"`
}
type InternetRules_DomainSuffix struct {
	DomainSuffix bool `protobuf:"varint,9,opt,name=domain_suffix,json=domainSuffix,oneof"`
}
type InternetRules_MacAddress struct {
	MacAddress bool `protobuf:"varint,10,opt,name=mac_address,json=macAddress,oneof"`
}
type InternetRules_Ipv4Address struct {
	Ipv4Address bool `protobuf:"varint,11,opt,name=ipv4_address,json=ipv4Address,oneof"`
}
type InternetRules_Ipv6Address struct {
	Ipv6Address bool `protobuf:"varint,12,opt,name=ipv6_address,json=ipv6Address,oneof"`
}
type InternetRules_Url struct {
	Url bool `protobuf:"varint,13,opt,name=url,oneof"`
}
type InternetRules_Slug struct {
	Slug bool `protobuf:"varint,14,opt,name=slug,oneof"`
}

func (*InternetRules_Email) isInternetRules_Type()        {}
func (*InternetRules_FreeEmail) isInternetRules_Type()    {}
func (*InternetRules_SafeEmail) isInternetRules_Type()    {}
func (*InternetRules_UserName) isInternetRules_Type()     {}
func (*InternetRules_Password) isInternetRules_Type()     {}
func (*InternetRules_DomainName) isInternetRules_Type()   {}
func (*InternetRules_DomainWord) isInternetRules_Type()   {}
func (*InternetRules_DomainSuffix) isInternetRules_Type() {}
func (*InternetRules_MacAddress) isInternetRules_Type()   {}
func (*InternetRules_Ipv4Address) isInternetRules_Type()  {}
func (*InternetRules_Ipv6Address) isInternetRules_Type()  {}
func (*InternetRules_Url) isInternetRules_Type()          {}
func (*InternetRules_Slug) isInternetRules_Type()         {}

func (m *InternetRules) GetType() isInternetRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *InternetRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *InternetRules) GetEmail() bool {
	if x, ok := m.GetType().(*InternetRules_Email); ok {
		return x.Email
	}
	return false
}

func (m *InternetRules) GetFreeEmail() bool {
	if x, ok := m.GetType().(*InternetRules_FreeEmail); ok {
		return x.FreeEmail
	}
	return false
}

func (m *InternetRules) GetSafeEmail() bool {
	if x, ok := m.GetType().(*InternetRules_SafeEmail); ok {
		return x.SafeEmail
	}
	return false
}

func (m *InternetRules) GetUserName() bool {
	if x, ok := m.GetType().(*InternetRules_UserName); ok {
		return x.UserName
	}
	return false
}

func (m *InternetRules) GetPassword() *InternetRulesPassword {
	if x, ok := m.GetType().(*InternetRules_Password); ok {
		return x.Password
	}
	return nil
}

func (m *InternetRules) GetDomainName() bool {
	if x, ok := m.GetType().(*InternetRules_DomainName); ok {
		return x.DomainName
	}
	return false
}

func (m *InternetRules) GetDomainWord() bool {
	if x, ok := m.GetType().(*InternetRules_DomainWord); ok {
		return x.DomainWord
	}
	return false
}

func (m *InternetRules) GetDomainSuffix() bool {
	if x, ok := m.GetType().(*InternetRules_DomainSuffix); ok {
		return x.DomainSuffix
	}
	return false
}

func (m *InternetRules) GetMacAddress() bool {
	if x, ok := m.GetType().(*InternetRules_MacAddress); ok {
		return x.MacAddress
	}
	return false
}

func (m *InternetRules) GetIpv4Address() bool {
	if x, ok := m.GetType().(*InternetRules_Ipv4Address); ok {
		return x.Ipv4Address
	}
	return false
}

func (m *InternetRules) GetIpv6Address() bool {
	if x, ok := m.GetType().(*InternetRules_Ipv6Address); ok {
		return x.Ipv6Address
	}
	return false
}

func (m *InternetRules) GetUrl() bool {
	if x, ok := m.GetType().(*InternetRules_Url); ok {
		return x.Url
	}
	return false
}

func (m *InternetRules) GetSlug() bool {
	if x, ok := m.GetType().(*InternetRules_Slug); ok {
		return x.Slug
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InternetRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InternetRules_OneofMarshaler, _InternetRules_OneofUnmarshaler, _InternetRules_OneofSizer, []interface{}{
		(*InternetRules_Email)(nil),
		(*InternetRules_FreeEmail)(nil),
		(*InternetRules_SafeEmail)(nil),
		(*InternetRules_UserName)(nil),
		(*InternetRules_Password)(nil),
		(*InternetRules_DomainName)(nil),
		(*InternetRules_DomainWord)(nil),
		(*InternetRules_DomainSuffix)(nil),
		(*InternetRules_MacAddress)(nil),
		(*InternetRules_Ipv4Address)(nil),
		(*InternetRules_Ipv6Address)(nil),
		(*InternetRules_Url)(nil),
		(*InternetRules_Slug)(nil),
	}
}

func _InternetRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InternetRules)
	// type
	switch x := m.Type.(type) {
	case *InternetRules_Email:
		t := uint64(0)
		if x.Email {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_FreeEmail:
		t := uint64(0)
		if x.FreeEmail {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_SafeEmail:
		t := uint64(0)
		if x.SafeEmail {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_UserName:
		t := uint64(0)
		if x.UserName {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_Password:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Password); err != nil {
			return err
		}
	case *InternetRules_DomainName:
		t := uint64(0)
		if x.DomainName {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_DomainWord:
		t := uint64(0)
		if x.DomainWord {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_DomainSuffix:
		t := uint64(0)
		if x.DomainSuffix {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_MacAddress:
		t := uint64(0)
		if x.MacAddress {
			t = 1
		}
		_ = b.EncodeVarint(10<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_Ipv4Address:
		t := uint64(0)
		if x.Ipv4Address {
			t = 1
		}
		_ = b.EncodeVarint(11<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_Ipv6Address:
		t := uint64(0)
		if x.Ipv6Address {
			t = 1
		}
		_ = b.EncodeVarint(12<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_Url:
		t := uint64(0)
		if x.Url {
			t = 1
		}
		_ = b.EncodeVarint(13<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *InternetRules_Slug:
		t := uint64(0)
		if x.Slug {
			t = 1
		}
		_ = b.EncodeVarint(14<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("InternetRules.Type has unexpected type %T", x)
	}
	return nil
}

func _InternetRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InternetRules)
	switch tag {
	case 2: // type.email
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_Email{x != 0}
		return true, err
	case 3: // type.free_email
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_FreeEmail{x != 0}
		return true, err
	case 4: // type.safe_email
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_SafeEmail{x != 0}
		return true, err
	case 5: // type.user_name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_UserName{x != 0}
		return true, err
	case 6: // type.password
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InternetRulesPassword)
		err := b.DecodeMessage(msg)
		m.Type = &InternetRules_Password{msg}
		return true, err
	case 7: // type.domain_name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_DomainName{x != 0}
		return true, err
	case 8: // type.domain_word
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_DomainWord{x != 0}
		return true, err
	case 9: // type.domain_suffix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_DomainSuffix{x != 0}
		return true, err
	case 10: // type.mac_address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_MacAddress{x != 0}
		return true, err
	case 11: // type.ipv4_address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_Ipv4Address{x != 0}
		return true, err
	case 12: // type.ipv6_address
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_Ipv6Address{x != 0}
		return true, err
	case 13: // type.url
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_Url{x != 0}
		return true, err
	case 14: // type.slug
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &InternetRules_Slug{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _InternetRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InternetRules)
	// type
	switch x := m.Type.(type) {
	case *InternetRules_Email:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_FreeEmail:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_SafeEmail:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_UserName:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_Password:
		s := proto.Size(x.Password)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InternetRules_DomainName:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_DomainWord:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_DomainSuffix:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_MacAddress:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_Ipv4Address:
		n += proto.SizeVarint(11<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_Ipv6Address:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_Url:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += 1
	case *InternetRules_Slug:
		n += proto.SizeVarint(14<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type InternetRulesPassword struct {
	Min              *int32 `protobuf:"varint,1,req,name=min" json:"min,omitempty"`
	Max              *int32 `protobuf:"varint,2,req,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternetRulesPassword) Reset()         { *m = InternetRulesPassword{} }
func (m *InternetRulesPassword) String() string { return proto.CompactTextString(m) }
func (*InternetRulesPassword) ProtoMessage()    {}
func (*InternetRulesPassword) Descriptor() ([]byte, []int) {
	return fileDescriptorGomeetfaker, []int{21}
}

func (m *InternetRulesPassword) GetMin() int32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *InternetRulesPassword) GetMax() int32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type LoremRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*LoremRules_Character
	//	*LoremRules_Characters
	//	*LoremRules_Word
	//	*LoremRules_Words
	//	*LoremRules_Sentence
	//	*LoremRules_Sentences
	//	*LoremRules_Paragraph
	//	*LoremRules_Paragraphs
	//	*LoremRules_String_
	Type             isLoremRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *LoremRules) Reset()                    { *m = LoremRules{} }
func (m *LoremRules) String() string            { return proto.CompactTextString(m) }
func (*LoremRules) ProtoMessage()               {}
func (*LoremRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{22} }

type isLoremRules_Type interface {
	isLoremRules_Type()
}

type LoremRules_Character struct {
	Character bool `protobuf:"varint,2,opt,name=character,oneof"`
}
type LoremRules_Characters struct {
	Characters *LoremRulesNum `protobuf:"bytes,3,opt,name=characters,oneof"`
}
type LoremRules_Word struct {
	Word bool `protobuf:"varint,4,opt,name=word,oneof"`
}
type LoremRules_Words struct {
	Words *LoremRulesNum `protobuf:"bytes,5,opt,name=words,oneof"`
}
type LoremRules_Sentence struct {
	Sentence *LoremRulesSentence `protobuf:"bytes,6,opt,name=sentence,oneof"`
}
type LoremRules_Sentences struct {
	Sentences *LoremRulesNum `protobuf:"bytes,7,opt,name=sentences,oneof"`
}
type LoremRules_Paragraph struct {
	Paragraph *LoremRulesParagraph `protobuf:"bytes,8,opt,name=paragraph,oneof"`
}
type LoremRules_Paragraphs struct {
	Paragraphs *LoremRulesNum `protobuf:"bytes,9,opt,name=paragraphs,oneof"`
}
type LoremRules_String_ struct {
	String_ bool `protobuf:"varint,10,opt,name=string,oneof"`
}

func (*LoremRules_Character) isLoremRules_Type()  {}
func (*LoremRules_Characters) isLoremRules_Type() {}
func (*LoremRules_Word) isLoremRules_Type()       {}
func (*LoremRules_Words) isLoremRules_Type()      {}
func (*LoremRules_Sentence) isLoremRules_Type()   {}
func (*LoremRules_Sentences) isLoremRules_Type()  {}
func (*LoremRules_Paragraph) isLoremRules_Type()  {}
func (*LoremRules_Paragraphs) isLoremRules_Type() {}
func (*LoremRules_String_) isLoremRules_Type()    {}

func (m *LoremRules) GetType() isLoremRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LoremRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *LoremRules) GetCharacter() bool {
	if x, ok := m.GetType().(*LoremRules_Character); ok {
		return x.Character
	}
	return false
}

func (m *LoremRules) GetCharacters() *LoremRulesNum {
	if x, ok := m.GetType().(*LoremRules_Characters); ok {
		return x.Characters
	}
	return nil
}

func (m *LoremRules) GetWord() bool {
	if x, ok := m.GetType().(*LoremRules_Word); ok {
		return x.Word
	}
	return false
}

func (m *LoremRules) GetWords() *LoremRulesNum {
	if x, ok := m.GetType().(*LoremRules_Words); ok {
		return x.Words
	}
	return nil
}

func (m *LoremRules) GetSentence() *LoremRulesSentence {
	if x, ok := m.GetType().(*LoremRules_Sentence); ok {
		return x.Sentence
	}
	return nil
}

func (m *LoremRules) GetSentences() *LoremRulesNum {
	if x, ok := m.GetType().(*LoremRules_Sentences); ok {
		return x.Sentences
	}
	return nil
}

func (m *LoremRules) GetParagraph() *LoremRulesParagraph {
	if x, ok := m.GetType().(*LoremRules_Paragraph); ok {
		return x.Paragraph
	}
	return nil
}

func (m *LoremRules) GetParagraphs() *LoremRulesNum {
	if x, ok := m.GetType().(*LoremRules_Paragraphs); ok {
		return x.Paragraphs
	}
	return nil
}

func (m *LoremRules) GetString_() bool {
	if x, ok := m.GetType().(*LoremRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoremRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoremRules_OneofMarshaler, _LoremRules_OneofUnmarshaler, _LoremRules_OneofSizer, []interface{}{
		(*LoremRules_Character)(nil),
		(*LoremRules_Characters)(nil),
		(*LoremRules_Word)(nil),
		(*LoremRules_Words)(nil),
		(*LoremRules_Sentence)(nil),
		(*LoremRules_Sentences)(nil),
		(*LoremRules_Paragraph)(nil),
		(*LoremRules_Paragraphs)(nil),
		(*LoremRules_String_)(nil),
	}
}

func _LoremRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoremRules)
	// type
	switch x := m.Type.(type) {
	case *LoremRules_Character:
		t := uint64(0)
		if x.Character {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *LoremRules_Characters:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Characters); err != nil {
			return err
		}
	case *LoremRules_Word:
		t := uint64(0)
		if x.Word {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *LoremRules_Words:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Words); err != nil {
			return err
		}
	case *LoremRules_Sentence:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sentence); err != nil {
			return err
		}
	case *LoremRules_Sentences:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sentences); err != nil {
			return err
		}
	case *LoremRules_Paragraph:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Paragraph); err != nil {
			return err
		}
	case *LoremRules_Paragraphs:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Paragraphs); err != nil {
			return err
		}
	case *LoremRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(10<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("LoremRules.Type has unexpected type %T", x)
	}
	return nil
}

func _LoremRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoremRules)
	switch tag {
	case 2: // type.character
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &LoremRules_Character{x != 0}
		return true, err
	case 3: // type.characters
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRulesNum)
		err := b.DecodeMessage(msg)
		m.Type = &LoremRules_Characters{msg}
		return true, err
	case 4: // type.word
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &LoremRules_Word{x != 0}
		return true, err
	case 5: // type.words
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRulesNum)
		err := b.DecodeMessage(msg)
		m.Type = &LoremRules_Words{msg}
		return true, err
	case 6: // type.sentence
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRulesSentence)
		err := b.DecodeMessage(msg)
		m.Type = &LoremRules_Sentence{msg}
		return true, err
	case 7: // type.sentences
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRulesNum)
		err := b.DecodeMessage(msg)
		m.Type = &LoremRules_Sentences{msg}
		return true, err
	case 8: // type.paragraph
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRulesParagraph)
		err := b.DecodeMessage(msg)
		m.Type = &LoremRules_Paragraph{msg}
		return true, err
	case 9: // type.paragraphs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoremRulesNum)
		err := b.DecodeMessage(msg)
		m.Type = &LoremRules_Paragraphs{msg}
		return true, err
	case 10: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &LoremRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _LoremRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoremRules)
	// type
	switch x := m.Type.(type) {
	case *LoremRules_Character:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *LoremRules_Characters:
		s := proto.Size(x.Characters)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoremRules_Word:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *LoremRules_Words:
		s := proto.Size(x.Words)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoremRules_Sentence:
		s := proto.Size(x.Sentence)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoremRules_Sentences:
		s := proto.Size(x.Sentences)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoremRules_Paragraph:
		s := proto.Size(x.Paragraph)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoremRules_Paragraphs:
		s := proto.Size(x.Paragraphs)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoremRules_String_:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LoremRulesNum struct {
	Num              *uint32 `protobuf:"varint,1,req,name=num" json:"num,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoremRulesNum) Reset()                    { *m = LoremRulesNum{} }
func (m *LoremRulesNum) String() string            { return proto.CompactTextString(m) }
func (*LoremRulesNum) ProtoMessage()               {}
func (*LoremRulesNum) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{23} }

func (m *LoremRulesNum) GetNum() uint32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type LoremRulesSentence struct {
	Words            *uint32 `protobuf:"varint,1,req,name=words" json:"words,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoremRulesSentence) Reset()                    { *m = LoremRulesSentence{} }
func (m *LoremRulesSentence) String() string            { return proto.CompactTextString(m) }
func (*LoremRulesSentence) ProtoMessage()               {}
func (*LoremRulesSentence) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{24} }

func (m *LoremRulesSentence) GetWords() uint32 {
	if m != nil && m.Words != nil {
		return *m.Words
	}
	return 0
}

type LoremRulesParagraph struct {
	Sentence         *uint32 `protobuf:"varint,1,req,name=sentence" json:"sentence,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoremRulesParagraph) Reset()                    { *m = LoremRulesParagraph{} }
func (m *LoremRulesParagraph) String() string            { return proto.CompactTextString(m) }
func (*LoremRulesParagraph) ProtoMessage()               {}
func (*LoremRulesParagraph) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{25} }

func (m *LoremRulesParagraph) GetSentence() uint32 {
	if m != nil && m.Sentence != nil {
		return *m.Sentence
	}
	return 0
}

type NameRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*NameRules_Name
	//	*NameRules_FirstName
	//	*NameRules_LastName
	//	*NameRules_Prefix
	//	*NameRules_Suffix
	//	*NameRules_Title
	//	*NameRules_String_
	Type             isNameRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *NameRules) Reset()                    { *m = NameRules{} }
func (m *NameRules) String() string            { return proto.CompactTextString(m) }
func (*NameRules) ProtoMessage()               {}
func (*NameRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{26} }

type isNameRules_Type interface {
	isNameRules_Type()
}

type NameRules_Name struct {
	Name bool `protobuf:"varint,2,opt,name=name,oneof"`
}
type NameRules_FirstName struct {
	FirstName bool `protobuf:"varint,3,opt,name=first_name,json=firstName,oneof"`
}
type NameRules_LastName struct {
	LastName bool `protobuf:"varint,4,opt,name=last_name,json=lastName,oneof"`
}
type NameRules_Prefix struct {
	Prefix bool `protobuf:"varint,5,opt,name=prefix,oneof"`
}
type NameRules_Suffix struct {
	Suffix bool `protobuf:"varint,6,opt,name=suffix,oneof"`
}
type NameRules_Title struct {
	Title bool `protobuf:"varint,7,opt,name=title,oneof"`
}
type NameRules_String_ struct {
	String_ bool `protobuf:"varint,8,opt,name=string,oneof"`
}

func (*NameRules_Name) isNameRules_Type()      {}
func (*NameRules_FirstName) isNameRules_Type() {}
func (*NameRules_LastName) isNameRules_Type()  {}
func (*NameRules_Prefix) isNameRules_Type()    {}
func (*NameRules_Suffix) isNameRules_Type()    {}
func (*NameRules_Title) isNameRules_Type()     {}
func (*NameRules_String_) isNameRules_Type()   {}

func (m *NameRules) GetType() isNameRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *NameRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *NameRules) GetName() bool {
	if x, ok := m.GetType().(*NameRules_Name); ok {
		return x.Name
	}
	return false
}

func (m *NameRules) GetFirstName() bool {
	if x, ok := m.GetType().(*NameRules_FirstName); ok {
		return x.FirstName
	}
	return false
}

func (m *NameRules) GetLastName() bool {
	if x, ok := m.GetType().(*NameRules_LastName); ok {
		return x.LastName
	}
	return false
}

func (m *NameRules) GetPrefix() bool {
	if x, ok := m.GetType().(*NameRules_Prefix); ok {
		return x.Prefix
	}
	return false
}

func (m *NameRules) GetSuffix() bool {
	if x, ok := m.GetType().(*NameRules_Suffix); ok {
		return x.Suffix
	}
	return false
}

func (m *NameRules) GetTitle() bool {
	if x, ok := m.GetType().(*NameRules_Title); ok {
		return x.Title
	}
	return false
}

func (m *NameRules) GetString_() bool {
	if x, ok := m.GetType().(*NameRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NameRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NameRules_OneofMarshaler, _NameRules_OneofUnmarshaler, _NameRules_OneofSizer, []interface{}{
		(*NameRules_Name)(nil),
		(*NameRules_FirstName)(nil),
		(*NameRules_LastName)(nil),
		(*NameRules_Prefix)(nil),
		(*NameRules_Suffix)(nil),
		(*NameRules_Title)(nil),
		(*NameRules_String_)(nil),
	}
}

func _NameRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NameRules)
	// type
	switch x := m.Type.(type) {
	case *NameRules_Name:
		t := uint64(0)
		if x.Name {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NameRules_FirstName:
		t := uint64(0)
		if x.FirstName {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NameRules_LastName:
		t := uint64(0)
		if x.LastName {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NameRules_Prefix:
		t := uint64(0)
		if x.Prefix {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NameRules_Suffix:
		t := uint64(0)
		if x.Suffix {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NameRules_Title:
		t := uint64(0)
		if x.Title {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NameRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("NameRules.Type has unexpected type %T", x)
	}
	return nil
}

func _NameRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NameRules)
	switch tag {
	case 2: // type.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_Name{x != 0}
		return true, err
	case 3: // type.first_name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_FirstName{x != 0}
		return true, err
	case 4: // type.last_name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_LastName{x != 0}
		return true, err
	case 5: // type.prefix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_Prefix{x != 0}
		return true, err
	case 6: // type.suffix
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_Suffix{x != 0}
		return true, err
	case 7: // type.title
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_Title{x != 0}
		return true, err
	case 8: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NameRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _NameRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NameRules)
	// type
	switch x := m.Type.(type) {
	case *NameRules_Name:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *NameRules_FirstName:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *NameRules_LastName:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *NameRules_Prefix:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *NameRules_Suffix:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case *NameRules_Title:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case *NameRules_String_:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NumberRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*NumberRules_Number
	//	*NumberRules_Decimal
	//	*NumberRules_Digit
	//	*NumberRules_Hexadecimal
	//	*NumberRules_Between
	//	*NumberRules_Positive
	//	*NumberRules_Negative
	Type             isNumberRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *NumberRules) Reset()                    { *m = NumberRules{} }
func (m *NumberRules) String() string            { return proto.CompactTextString(m) }
func (*NumberRules) ProtoMessage()               {}
func (*NumberRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{27} }

type isNumberRules_Type interface {
	isNumberRules_Type()
}

type NumberRules_Number struct {
	Number *NumberRulesDigit `protobuf:"bytes,2,opt,name=number,oneof"`
}
type NumberRules_Decimal struct {
	Decimal *NumberRulesDecimal `protobuf:"bytes,3,opt,name=decimal,oneof"`
}
type NumberRules_Digit struct {
	Digit bool `protobuf:"varint,4,opt,name=digit,oneof"`
}
type NumberRules_Hexadecimal struct {
	Hexadecimal *NumberRulesDigit `protobuf:"bytes,5,opt,name=hexadecimal,oneof"`
}
type NumberRules_Between struct {
	Between *NumberRulesBetween `protobuf:"bytes,6,opt,name=between,oneof"`
}
type NumberRules_Positive struct {
	Positive *NumberRulesPositive `protobuf:"bytes,7,opt,name=positive,oneof"`
}
type NumberRules_Negative struct {
	Negative *NumberRulesNegative `protobuf:"bytes,8,opt,name=negative,oneof"`
}

func (*NumberRules_Number) isNumberRules_Type()      {}
func (*NumberRules_Decimal) isNumberRules_Type()     {}
func (*NumberRules_Digit) isNumberRules_Type()       {}
func (*NumberRules_Hexadecimal) isNumberRules_Type() {}
func (*NumberRules_Between) isNumberRules_Type()     {}
func (*NumberRules_Positive) isNumberRules_Type()    {}
func (*NumberRules_Negative) isNumberRules_Type()    {}

func (m *NumberRules) GetType() isNumberRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *NumberRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *NumberRules) GetNumber() *NumberRulesDigit {
	if x, ok := m.GetType().(*NumberRules_Number); ok {
		return x.Number
	}
	return nil
}

func (m *NumberRules) GetDecimal() *NumberRulesDecimal {
	if x, ok := m.GetType().(*NumberRules_Decimal); ok {
		return x.Decimal
	}
	return nil
}

func (m *NumberRules) GetDigit() bool {
	if x, ok := m.GetType().(*NumberRules_Digit); ok {
		return x.Digit
	}
	return false
}

func (m *NumberRules) GetHexadecimal() *NumberRulesDigit {
	if x, ok := m.GetType().(*NumberRules_Hexadecimal); ok {
		return x.Hexadecimal
	}
	return nil
}

func (m *NumberRules) GetBetween() *NumberRulesBetween {
	if x, ok := m.GetType().(*NumberRules_Between); ok {
		return x.Between
	}
	return nil
}

func (m *NumberRules) GetPositive() *NumberRulesPositive {
	if x, ok := m.GetType().(*NumberRules_Positive); ok {
		return x.Positive
	}
	return nil
}

func (m *NumberRules) GetNegative() *NumberRulesNegative {
	if x, ok := m.GetType().(*NumberRules_Negative); ok {
		return x.Negative
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NumberRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NumberRules_OneofMarshaler, _NumberRules_OneofUnmarshaler, _NumberRules_OneofSizer, []interface{}{
		(*NumberRules_Number)(nil),
		(*NumberRules_Decimal)(nil),
		(*NumberRules_Digit)(nil),
		(*NumberRules_Hexadecimal)(nil),
		(*NumberRules_Between)(nil),
		(*NumberRules_Positive)(nil),
		(*NumberRules_Negative)(nil),
	}
}

func _NumberRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NumberRules)
	// type
	switch x := m.Type.(type) {
	case *NumberRules_Number:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Number); err != nil {
			return err
		}
	case *NumberRules_Decimal:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Decimal); err != nil {
			return err
		}
	case *NumberRules_Digit:
		t := uint64(0)
		if x.Digit {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NumberRules_Hexadecimal:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hexadecimal); err != nil {
			return err
		}
	case *NumberRules_Between:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Between); err != nil {
			return err
		}
	case *NumberRules_Positive:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Positive); err != nil {
			return err
		}
	case *NumberRules_Negative:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Negative); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NumberRules.Type has unexpected type %T", x)
	}
	return nil
}

func _NumberRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NumberRules)
	switch tag {
	case 2: // type.number
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRulesDigit)
		err := b.DecodeMessage(msg)
		m.Type = &NumberRules_Number{msg}
		return true, err
	case 3: // type.decimal
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRulesDecimal)
		err := b.DecodeMessage(msg)
		m.Type = &NumberRules_Decimal{msg}
		return true, err
	case 4: // type.digit
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NumberRules_Digit{x != 0}
		return true, err
	case 5: // type.hexadecimal
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRulesDigit)
		err := b.DecodeMessage(msg)
		m.Type = &NumberRules_Hexadecimal{msg}
		return true, err
	case 6: // type.between
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRulesBetween)
		err := b.DecodeMessage(msg)
		m.Type = &NumberRules_Between{msg}
		return true, err
	case 7: // type.positive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRulesPositive)
		err := b.DecodeMessage(msg)
		m.Type = &NumberRules_Positive{msg}
		return true, err
	case 8: // type.negative
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberRulesNegative)
		err := b.DecodeMessage(msg)
		m.Type = &NumberRules_Negative{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NumberRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NumberRules)
	// type
	switch x := m.Type.(type) {
	case *NumberRules_Number:
		s := proto.Size(x.Number)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NumberRules_Decimal:
		s := proto.Size(x.Decimal)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NumberRules_Digit:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *NumberRules_Hexadecimal:
		s := proto.Size(x.Hexadecimal)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NumberRules_Between:
		s := proto.Size(x.Between)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NumberRules_Positive:
		s := proto.Size(x.Positive)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NumberRules_Negative:
		s := proto.Size(x.Negative)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NumberRulesDigit struct {
	Digits           *uint32 `protobuf:"varint,1,req,name=digits" json:"digits,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NumberRulesDigit) Reset()                    { *m = NumberRulesDigit{} }
func (m *NumberRulesDigit) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesDigit) ProtoMessage()               {}
func (*NumberRulesDigit) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{28} }

func (m *NumberRulesDigit) GetDigits() uint32 {
	if m != nil && m.Digits != nil {
		return *m.Digits
	}
	return 0
}

type NumberRulesDecimal struct {
	Precision        *uint32 `protobuf:"varint,1,req,name=precision" json:"precision,omitempty"`
	Scale            *uint32 `protobuf:"varint,2,req,name=scale" json:"scale,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NumberRulesDecimal) Reset()                    { *m = NumberRulesDecimal{} }
func (m *NumberRulesDecimal) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesDecimal) ProtoMessage()               {}
func (*NumberRulesDecimal) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{29} }

func (m *NumberRulesDecimal) GetPrecision() uint32 {
	if m != nil && m.Precision != nil {
		return *m.Precision
	}
	return 0
}

func (m *NumberRulesDecimal) GetScale() uint32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return 0
}

type NumberRulesBetween struct {
	Min              *uint32 `protobuf:"varint,1,req,name=min" json:"min,omitempty"`
	Max              *uint32 `protobuf:"varint,2,req,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NumberRulesBetween) Reset()                    { *m = NumberRulesBetween{} }
func (m *NumberRulesBetween) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesBetween) ProtoMessage()               {}
func (*NumberRulesBetween) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{30} }

func (m *NumberRulesBetween) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *NumberRulesBetween) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type NumberRulesPositive struct {
	Max              *uint32 `protobuf:"varint,1,req,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NumberRulesPositive) Reset()                    { *m = NumberRulesPositive{} }
func (m *NumberRulesPositive) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesPositive) ProtoMessage()               {}
func (*NumberRulesPositive) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{31} }

func (m *NumberRulesPositive) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type NumberRulesNegative struct {
	Min              *int32 `protobuf:"varint,1,req,name=min" json:"min,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *NumberRulesNegative) Reset()                    { *m = NumberRulesNegative{} }
func (m *NumberRulesNegative) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesNegative) ProtoMessage()               {}
func (*NumberRulesNegative) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{32} }

func (m *NumberRulesNegative) GetMin() int32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

type NumberRulesCount struct {
	C                *int32 `protobuf:"varint,1,req,name=c" json:"c,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *NumberRulesCount) Reset()                    { *m = NumberRulesCount{} }
func (m *NumberRulesCount) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesCount) ProtoMessage()               {}
func (*NumberRulesCount) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{33} }

func (m *NumberRulesCount) GetC() int32 {
	if m != nil && m.C != nil {
		return *m.C
	}
	return 0
}

type NumberRulesCount2 struct {
	C1               *int32 `protobuf:"varint,1,req,name=c1" json:"c1,omitempty"`
	C2               *int32 `protobuf:"varint,2,req,name=c2" json:"c2,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *NumberRulesCount2) Reset()                    { *m = NumberRulesCount2{} }
func (m *NumberRulesCount2) String() string            { return proto.CompactTextString(m) }
func (*NumberRulesCount2) ProtoMessage()               {}
func (*NumberRulesCount2) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{34} }

func (m *NumberRulesCount2) GetC1() int32 {
	if m != nil && m.C1 != nil {
		return *m.C1
	}
	return 0
}

func (m *NumberRulesCount2) GetC2() int32 {
	if m != nil && m.C2 != nil {
		return *m.C2
	}
	return 0
}

type PhoneNumberRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*PhoneNumberRules_PhoneNumber
	//	*PhoneNumberRules_CellPhone
	//	*PhoneNumberRules_AreaCode
	//	*PhoneNumberRules_ExchangeCode
	//	*PhoneNumberRules_SubscriberNumber
	//	*PhoneNumberRules_String_
	Type             isPhoneNumberRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *PhoneNumberRules) Reset()                    { *m = PhoneNumberRules{} }
func (m *PhoneNumberRules) String() string            { return proto.CompactTextString(m) }
func (*PhoneNumberRules) ProtoMessage()               {}
func (*PhoneNumberRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{35} }

type isPhoneNumberRules_Type interface {
	isPhoneNumberRules_Type()
}

type PhoneNumberRules_PhoneNumber struct {
	PhoneNumber bool `protobuf:"varint,2,opt,name=phone_number,json=phoneNumber,oneof"`
}
type PhoneNumberRules_CellPhone struct {
	CellPhone bool `protobuf:"varint,3,opt,name=cell_phone,json=cellPhone,oneof"`
}
type PhoneNumberRules_AreaCode struct {
	AreaCode bool `protobuf:"varint,4,opt,name=area_code,json=areaCode,oneof"`
}
type PhoneNumberRules_ExchangeCode struct {
	ExchangeCode bool `protobuf:"varint,5,opt,name=exchange_code,json=exchangeCode,oneof"`
}
type PhoneNumberRules_SubscriberNumber struct {
	SubscriberNumber *PhoneNumberRulesDigit `protobuf:"bytes,6,opt,name=subscriber_number,json=subscriberNumber,oneof"`
}
type PhoneNumberRules_String_ struct {
	String_ bool `protobuf:"varint,7,opt,name=string,oneof"`
}

func (*PhoneNumberRules_PhoneNumber) isPhoneNumberRules_Type()      {}
func (*PhoneNumberRules_CellPhone) isPhoneNumberRules_Type()        {}
func (*PhoneNumberRules_AreaCode) isPhoneNumberRules_Type()         {}
func (*PhoneNumberRules_ExchangeCode) isPhoneNumberRules_Type()     {}
func (*PhoneNumberRules_SubscriberNumber) isPhoneNumberRules_Type() {}
func (*PhoneNumberRules_String_) isPhoneNumberRules_Type()          {}

func (m *PhoneNumberRules) GetType() isPhoneNumberRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *PhoneNumberRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *PhoneNumberRules) GetPhoneNumber() bool {
	if x, ok := m.GetType().(*PhoneNumberRules_PhoneNumber); ok {
		return x.PhoneNumber
	}
	return false
}

func (m *PhoneNumberRules) GetCellPhone() bool {
	if x, ok := m.GetType().(*PhoneNumberRules_CellPhone); ok {
		return x.CellPhone
	}
	return false
}

func (m *PhoneNumberRules) GetAreaCode() bool {
	if x, ok := m.GetType().(*PhoneNumberRules_AreaCode); ok {
		return x.AreaCode
	}
	return false
}

func (m *PhoneNumberRules) GetExchangeCode() bool {
	if x, ok := m.GetType().(*PhoneNumberRules_ExchangeCode); ok {
		return x.ExchangeCode
	}
	return false
}

func (m *PhoneNumberRules) GetSubscriberNumber() *PhoneNumberRulesDigit {
	if x, ok := m.GetType().(*PhoneNumberRules_SubscriberNumber); ok {
		return x.SubscriberNumber
	}
	return nil
}

func (m *PhoneNumberRules) GetString_() bool {
	if x, ok := m.GetType().(*PhoneNumberRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PhoneNumberRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PhoneNumberRules_OneofMarshaler, _PhoneNumberRules_OneofUnmarshaler, _PhoneNumberRules_OneofSizer, []interface{}{
		(*PhoneNumberRules_PhoneNumber)(nil),
		(*PhoneNumberRules_CellPhone)(nil),
		(*PhoneNumberRules_AreaCode)(nil),
		(*PhoneNumberRules_ExchangeCode)(nil),
		(*PhoneNumberRules_SubscriberNumber)(nil),
		(*PhoneNumberRules_String_)(nil),
	}
}

func _PhoneNumberRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PhoneNumberRules)
	// type
	switch x := m.Type.(type) {
	case *PhoneNumberRules_PhoneNumber:
		t := uint64(0)
		if x.PhoneNumber {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *PhoneNumberRules_CellPhone:
		t := uint64(0)
		if x.CellPhone {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *PhoneNumberRules_AreaCode:
		t := uint64(0)
		if x.AreaCode {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *PhoneNumberRules_ExchangeCode:
		t := uint64(0)
		if x.ExchangeCode {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *PhoneNumberRules_SubscriberNumber:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SubscriberNumber); err != nil {
			return err
		}
	case *PhoneNumberRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("PhoneNumberRules.Type has unexpected type %T", x)
	}
	return nil
}

func _PhoneNumberRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PhoneNumberRules)
	switch tag {
	case 2: // type.phone_number
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &PhoneNumberRules_PhoneNumber{x != 0}
		return true, err
	case 3: // type.cell_phone
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &PhoneNumberRules_CellPhone{x != 0}
		return true, err
	case 4: // type.area_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &PhoneNumberRules_AreaCode{x != 0}
		return true, err
	case 5: // type.exchange_code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &PhoneNumberRules_ExchangeCode{x != 0}
		return true, err
	case 6: // type.subscriber_number
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PhoneNumberRulesDigit)
		err := b.DecodeMessage(msg)
		m.Type = &PhoneNumberRules_SubscriberNumber{msg}
		return true, err
	case 7: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &PhoneNumberRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _PhoneNumberRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PhoneNumberRules)
	// type
	switch x := m.Type.(type) {
	case *PhoneNumberRules_PhoneNumber:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *PhoneNumberRules_CellPhone:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *PhoneNumberRules_AreaCode:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *PhoneNumberRules_ExchangeCode:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *PhoneNumberRules_SubscriberNumber:
		s := proto.Size(x.SubscriberNumber)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PhoneNumberRules_String_:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PhoneNumberRulesDigit struct {
	Digits           *uint32 `protobuf:"varint,1,req,name=digits" json:"digits,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PhoneNumberRulesDigit) Reset()         { *m = PhoneNumberRulesDigit{} }
func (m *PhoneNumberRulesDigit) String() string { return proto.CompactTextString(m) }
func (*PhoneNumberRulesDigit) ProtoMessage()    {}
func (*PhoneNumberRulesDigit) Descriptor() ([]byte, []int) {
	return fileDescriptorGomeetfaker, []int{36}
}

func (m *PhoneNumberRulesDigit) GetDigits() uint32 {
	if m != nil && m.Digits != nil {
		return *m.Digits
	}
	return 0
}

type TeamRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*TeamRules_Name
	//	*TeamRules_Creature
	//	*TeamRules_State
	//	*TeamRules_String_
	Type             isTeamRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *TeamRules) Reset()                    { *m = TeamRules{} }
func (m *TeamRules) String() string            { return proto.CompactTextString(m) }
func (*TeamRules) ProtoMessage()               {}
func (*TeamRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{37} }

type isTeamRules_Type interface {
	isTeamRules_Type()
}

type TeamRules_Name struct {
	Name bool `protobuf:"varint,2,opt,name=name,oneof"`
}
type TeamRules_Creature struct {
	Creature bool `protobuf:"varint,3,opt,name=creature,oneof"`
}
type TeamRules_State struct {
	State bool `protobuf:"varint,4,opt,name=state,oneof"`
}
type TeamRules_String_ struct {
	String_ bool `protobuf:"varint,5,opt,name=string,oneof"`
}

func (*TeamRules_Name) isTeamRules_Type()     {}
func (*TeamRules_Creature) isTeamRules_Type() {}
func (*TeamRules_State) isTeamRules_Type()    {}
func (*TeamRules_String_) isTeamRules_Type()  {}

func (m *TeamRules) GetType() isTeamRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TeamRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *TeamRules) GetName() bool {
	if x, ok := m.GetType().(*TeamRules_Name); ok {
		return x.Name
	}
	return false
}

func (m *TeamRules) GetCreature() bool {
	if x, ok := m.GetType().(*TeamRules_Creature); ok {
		return x.Creature
	}
	return false
}

func (m *TeamRules) GetState() bool {
	if x, ok := m.GetType().(*TeamRules_State); ok {
		return x.State
	}
	return false
}

func (m *TeamRules) GetString_() bool {
	if x, ok := m.GetType().(*TeamRules_String_); ok {
		return x.String_
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TeamRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TeamRules_OneofMarshaler, _TeamRules_OneofUnmarshaler, _TeamRules_OneofSizer, []interface{}{
		(*TeamRules_Name)(nil),
		(*TeamRules_Creature)(nil),
		(*TeamRules_State)(nil),
		(*TeamRules_String_)(nil),
	}
}

func _TeamRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TeamRules)
	// type
	switch x := m.Type.(type) {
	case *TeamRules_Name:
		t := uint64(0)
		if x.Name {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TeamRules_Creature:
		t := uint64(0)
		if x.Creature {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TeamRules_State:
		t := uint64(0)
		if x.State {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *TeamRules_String_:
		t := uint64(0)
		if x.String_ {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TeamRules.Type has unexpected type %T", x)
	}
	return nil
}

func _TeamRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TeamRules)
	switch tag {
	case 2: // type.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &TeamRules_Name{x != 0}
		return true, err
	case 3: // type.creature
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &TeamRules_Creature{x != 0}
		return true, err
	case 4: // type.state
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &TeamRules_State{x != 0}
		return true, err
	case 5: // type.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &TeamRules_String_{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _TeamRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TeamRules)
	// type
	switch x := m.Type.(type) {
	case *TeamRules_Name:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *TeamRules_Creature:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *TeamRules_State:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *TeamRules_String_:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TimeRules struct {
	Repeated *uint32 `protobuf:"varint,1,opt,name=repeated" json:"repeated,omitempty"`
	Format   *string `protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*TimeRules_Between
	//	*TimeRules_Forward
	//	*TimeRules_Backward
	//	*TimeRules_Birthday
	//	*TimeRules_Now
	Type             isTimeRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *TimeRules) Reset()                    { *m = TimeRules{} }
func (m *TimeRules) String() string            { return proto.CompactTextString(m) }
func (*TimeRules) ProtoMessage()               {}
func (*TimeRules) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{38} }

type isTimeRules_Type interface {
	isTimeRules_Type()
}

type TimeRules_Between struct {
	Between *TimeRulesBetween `protobuf:"bytes,3,opt,name=between,oneof"`
}
type TimeRules_Forward struct {
	Forward string `protobuf:"bytes,4,opt,name=forward,oneof"`
}
type TimeRules_Backward struct {
	Backward string `protobuf:"bytes,5,opt,name=backward,oneof"`
}
type TimeRules_Birthday struct {
	Birthday *TimeRulesBirthday `protobuf:"bytes,6,opt,name=birthday,oneof"`
}
type TimeRules_Now struct {
	Now bool `protobuf:"varint,7,opt,name=now,oneof"`
}

func (*TimeRules_Between) isTimeRules_Type()  {}
func (*TimeRules_Forward) isTimeRules_Type()  {}
func (*TimeRules_Backward) isTimeRules_Type() {}
func (*TimeRules_Birthday) isTimeRules_Type() {}
func (*TimeRules_Now) isTimeRules_Type()      {}

func (m *TimeRules) GetType() isTimeRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TimeRules) GetRepeated() uint32 {
	if m != nil && m.Repeated != nil {
		return *m.Repeated
	}
	return 0
}

func (m *TimeRules) GetFormat() string {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return ""
}

func (m *TimeRules) GetBetween() *TimeRulesBetween {
	if x, ok := m.GetType().(*TimeRules_Between); ok {
		return x.Between
	}
	return nil
}

func (m *TimeRules) GetForward() string {
	if x, ok := m.GetType().(*TimeRules_Forward); ok {
		return x.Forward
	}
	return ""
}

func (m *TimeRules) GetBackward() string {
	if x, ok := m.GetType().(*TimeRules_Backward); ok {
		return x.Backward
	}
	return ""
}

func (m *TimeRules) GetBirthday() *TimeRulesBirthday {
	if x, ok := m.GetType().(*TimeRules_Birthday); ok {
		return x.Birthday
	}
	return nil
}

func (m *TimeRules) GetNow() bool {
	if x, ok := m.GetType().(*TimeRules_Now); ok {
		return x.Now
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TimeRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TimeRules_OneofMarshaler, _TimeRules_OneofUnmarshaler, _TimeRules_OneofSizer, []interface{}{
		(*TimeRules_Between)(nil),
		(*TimeRules_Forward)(nil),
		(*TimeRules_Backward)(nil),
		(*TimeRules_Birthday)(nil),
		(*TimeRules_Now)(nil),
	}
}

func _TimeRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TimeRules)
	// type
	switch x := m.Type.(type) {
	case *TimeRules_Between:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Between); err != nil {
			return err
		}
	case *TimeRules_Forward:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Forward)
	case *TimeRules_Backward:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Backward)
	case *TimeRules_Birthday:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Birthday); err != nil {
			return err
		}
	case *TimeRules_Now:
		t := uint64(0)
		if x.Now {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("TimeRules.Type has unexpected type %T", x)
	}
	return nil
}

func _TimeRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TimeRules)
	switch tag {
	case 3: // type.between
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimeRulesBetween)
		err := b.DecodeMessage(msg)
		m.Type = &TimeRules_Between{msg}
		return true, err
	case 4: // type.forward
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &TimeRules_Forward{x}
		return true, err
	case 5: // type.backward
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &TimeRules_Backward{x}
		return true, err
	case 6: // type.birthday
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimeRulesBirthday)
		err := b.DecodeMessage(msg)
		m.Type = &TimeRules_Birthday{msg}
		return true, err
	case 7: // type.now
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &TimeRules_Now{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _TimeRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TimeRules)
	// type
	switch x := m.Type.(type) {
	case *TimeRules_Between:
		s := proto.Size(x.Between)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TimeRules_Forward:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Forward)))
		n += len(x.Forward)
	case *TimeRules_Backward:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Backward)))
		n += len(x.Backward)
	case *TimeRules_Birthday:
		s := proto.Size(x.Birthday)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TimeRules_Now:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TimeRulesBirthday struct {
	Min              *int32 `protobuf:"varint,1,req,name=min" json:"min,omitempty"`
	Max              *int32 `protobuf:"varint,2,req,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TimeRulesBirthday) Reset()                    { *m = TimeRulesBirthday{} }
func (m *TimeRulesBirthday) String() string            { return proto.CompactTextString(m) }
func (*TimeRulesBirthday) ProtoMessage()               {}
func (*TimeRulesBirthday) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{39} }

func (m *TimeRulesBirthday) GetMin() int32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *TimeRulesBirthday) GetMax() int32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type TimeRulesBetween struct {
	From             *string `protobuf:"bytes,1,req,name=from" json:"from,omitempty"`
	To               *string `protobuf:"bytes,2,req,name=to" json:"to,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TimeRulesBetween) Reset()                    { *m = TimeRulesBetween{} }
func (m *TimeRulesBetween) String() string            { return proto.CompactTextString(m) }
func (*TimeRulesBetween) ProtoMessage()               {}
func (*TimeRulesBetween) Descriptor() ([]byte, []int) { return fileDescriptorGomeetfaker, []int{40} }

func (m *TimeRulesBetween) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *TimeRulesBetween) GetTo() string {
	if m != nil && m.To != nil {
		return *m.To
	}
	return ""
}

var E_Locale = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FileOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         13000,
	Name:          "gomeetfaker.locale",
	Tag:           "bytes,13000,opt,name=locale",
	Filename:      "gomeetfaker.proto",
}

var E_Field = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*FieldFakerRules)(nil),
	Field:         13001,
	Name:          "gomeetfaker.field",
	Tag:           "bytes,13001,opt,name=field",
	Filename:      "gomeetfaker.proto",
}

func init() {
	proto.RegisterType((*FieldFakerRules)(nil), "gomeetfaker.FieldFakerRules")
	proto.RegisterType((*ValueRules)(nil), "gomeetfaker.ValueRules")
	proto.RegisterType((*UuidRules)(nil), "gomeetfaker.UuidRules")
	proto.RegisterType((*EnumRules)(nil), "gomeetfaker.EnumRules")
	proto.RegisterType((*AddressRules)(nil), "gomeetfaker.AddressRules")
	proto.RegisterType((*AddressRulesByState)(nil), "gomeetfaker.AddressRulesByState")
	proto.RegisterType((*AppRules)(nil), "gomeetfaker.AppRules")
	proto.RegisterType((*AvatarRules)(nil), "gomeetfaker.AvatarRules")
	proto.RegisterType((*AvatarUrlRules)(nil), "gomeetfaker.AvatarUrlRules")
	proto.RegisterType((*BitcoinRules)(nil), "gomeetfaker.BitcoinRules")
	proto.RegisterType((*BusinessRules)(nil), "gomeetfaker.BusinessRules")
	proto.RegisterType((*CodeRules)(nil), "gomeetfaker.CodeRules")
	proto.RegisterType((*CommerceRules)(nil), "gomeetfaker.CommerceRules")
	proto.RegisterType((*CompanyRules)(nil), "gomeetfaker.CompanyRules")
	proto.RegisterType((*DateRules)(nil), "gomeetfaker.DateRules")
	proto.RegisterType((*DateRulesBirthday)(nil), "gomeetfaker.DateRulesBirthday")
	proto.RegisterType((*DateRulesBetween)(nil), "gomeetfaker.DateRulesBetween")
	proto.RegisterType((*FinanceRules)(nil), "gomeetfaker.FinanceRules")
	proto.RegisterType((*FinanceRulesCreditCard)(nil), "gomeetfaker.FinanceRulesCreditCard")
	proto.RegisterType((*HackerRules)(nil), "gomeetfaker.HackerRules")
	proto.RegisterType((*InternetRules)(nil), "gomeetfaker.InternetRules")
	proto.RegisterType((*InternetRulesPassword)(nil), "gomeetfaker.InternetRulesPassword")
	proto.RegisterType((*LoremRules)(nil), "gomeetfaker.LoremRules")
	proto.RegisterType((*LoremRulesNum)(nil), "gomeetfaker.LoremRulesNum")
	proto.RegisterType((*LoremRulesSentence)(nil), "gomeetfaker.LoremRulesSentence")
	proto.RegisterType((*LoremRulesParagraph)(nil), "gomeetfaker.LoremRulesParagraph")
	proto.RegisterType((*NameRules)(nil), "gomeetfaker.NameRules")
	proto.RegisterType((*NumberRules)(nil), "gomeetfaker.NumberRules")
	proto.RegisterType((*NumberRulesDigit)(nil), "gomeetfaker.NumberRulesDigit")
	proto.RegisterType((*NumberRulesDecimal)(nil), "gomeetfaker.NumberRulesDecimal")
	proto.RegisterType((*NumberRulesBetween)(nil), "gomeetfaker.NumberRulesBetween")
	proto.RegisterType((*NumberRulesPositive)(nil), "gomeetfaker.NumberRulesPositive")
	proto.RegisterType((*NumberRulesNegative)(nil), "gomeetfaker.NumberRulesNegative")
	proto.RegisterType((*NumberRulesCount)(nil), "gomeetfaker.NumberRulesCount")
	proto.RegisterType((*NumberRulesCount2)(nil), "gomeetfaker.NumberRulesCount2")
	proto.RegisterType((*PhoneNumberRules)(nil), "gomeetfaker.PhoneNumberRules")
	proto.RegisterType((*PhoneNumberRulesDigit)(nil), "gomeetfaker.PhoneNumberRulesDigit")
	proto.RegisterType((*TeamRules)(nil), "gomeetfaker.TeamRules")
	proto.RegisterType((*TimeRules)(nil), "gomeetfaker.TimeRules")
	proto.RegisterType((*TimeRulesBirthday)(nil), "gomeetfaker.TimeRulesBirthday")
	proto.RegisterType((*TimeRulesBetween)(nil), "gomeetfaker.TimeRulesBetween")
	proto.RegisterExtension(E_Locale)
	proto.RegisterExtension(E_Field)
}

func init() { proto.RegisterFile("gomeetfaker.proto", fileDescriptorGomeetfaker) }

var fileDescriptorGomeetfaker = []byte{
	// 2563 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0x4d, 0x73, 0x1b, 0xc7,
	0xd1, 0x36, 0x40, 0x82, 0x04, 0x1a, 0x00, 0x45, 0x8e, 0x24, 0x7a, 0x5f, 0x9a, 0xb2, 0x68, 0xe8,
	0x75, 0x59, 0x71, 0x1c, 0xc9, 0x92, 0xe3, 0x8f, 0xd8, 0x4e, 0xca, 0xa2, 0x2c, 0x95, 0x52, 0x95,
	0x30, 0x0a, 0x65, 0x3b, 0x55, 0xbe, 0xa0, 0x06, 0xbb, 0x43, 0x60, 0xa2, 0xfd, 0xaa, 0xd9, 0x59,
	0x8a, 0x54, 0xe5, 0x90, 0x53, 0x8e, 0x39, 0x25, 0x7f, 0x21, 0x87, 0x5c, 0x72, 0xce, 0x29, 0x57,
	0xe7, 0x98, 0xdf, 0x91, 0xca, 0x25, 0xbf, 0x20, 0xd5, 0x3d, 0x1f, 0xbb, 0x80, 0x16, 0xa0, 0x4a,
	0x55, 0xc9, 0x09, 0xdb, 0xdd, 0x4f, 0xcf, 0x4c, 0xf7, 0xcc, 0x3c, 0xd3, 0x33, 0x80, 0x9d, 0x69,
	0x96, 0x08, 0xa1, 0x4f, 0xf8, 0x53, 0xa1, 0x6e, 0xe5, 0x2a, 0xd3, 0x19, 0xeb, 0xd7, 0x54, 0x7b,
	0x07, 0xd3, 0x2c, 0x9b, 0xc6, 0xe2, 0x36, 0x99, 0x26, 0xe5, 0xc9, 0xed, 0x48, 0x14, 0xa1, 0x92,
	0xb9, 0xce, 0x2c, 0x7c, 0xef, 0xfa, 0x22, 0x42, 0xcb, 0x44, 0x14, 0x9a, 0x27, 0xb9, 0x01, 0x8c,
	0x7e, 0xd7, 0x83, 0x4b, 0x0f, 0xa5, 0x88, 0xa3, 0x87, 0xd8, 0xe2, 0x71, 0x19, 0x8b, 0x82, 0xdd,
	0x86, 0xce, 0x29, 0x8f, 0x4b, 0x11, 0xb4, 0x0e, 0x5a, 0x37, 0xfb, 0x77, 0x5f, 0xbf, 0x55, 0x1f,
	0xc6, 0x37, 0x68, 0x21, 0xdc, 0xa3, 0xd7, 0x8e, 0x0d, 0x8e, 0xbd, 0x07, 0xeb, 0x65, 0x29, 0xa3,
	0xa0, 0x4d, 0xf8, 0xdd, 0x39, 0xfc, 0xd7, 0xa5, 0x8c, 0x1c, 0x9c, 0x50, 0x88, 0x16, 0x69, 0x99,
	0x04, 0x6b, 0x0d, 0xe8, 0x07, 0x69, 0x99, 0x78, 0x34, 0xa2, 0xd8, 0x87, 0xb0, 0xc9, 0xa3, 0x48,
	0x89, 0xa2, 0x08, 0xd6, 0xc9, 0xe1, 0xff, 0xe6, 0x1c, 0xee, 0x19, 0x9b, 0xf3, 0x71, 0x58, 0xf6,
	0x3d, 0x58, 0xe3, 0x79, 0x1e, 0x74, 0xc8, 0xe5, 0xea, 0xbc, 0x4b, 0x9e, 0x3b, 0x38, 0x62, 0xd8,
	0x5d, 0xd8, 0xe0, 0xa7, 0x5c, 0x73, 0x15, 0x6c, 0x10, 0x3a, 0x98, 0x47, 0x93, 0xc9, 0x39, 0x58,
	0x24, 0x8e, 0x6a, 0x22, 0x75, 0x98, 0xc9, 0x34, 0xd8, 0x6c, 0x18, 0xd5, 0xa1, 0xb1, 0xf9, 0x51,
	0x59, 0x2c, 0xfb, 0x04, 0xba, 0x93, 0xb2, 0x90, 0x29, 0x46, 0xd3, 0x25, 0xbf, 0xbd, 0x79, 0x3f,
	0x6b, 0x74, 0x8e, 0x1e, 0x8d, 0x49, 0x0b, 0xb3, 0x48, 0x04, 0xbd, 0x86, 0xa4, 0xdd, 0xcf, 0x22,
	0x3f, 0x23, 0x84, 0xc2, 0x7e, 0xc2, 0x2c, 0x49, 0x84, 0x0a, 0x45, 0x00, 0x0d, 0xfd, 0xdc, 0xb7,
	0x46, 0xdf, 0x8f, 0x43, 0x63, 0x60, 0x61, 0x96, 0xe4, 0x3c, 0x3d, 0x0f, 0xfa, 0x0d, 0x81, 0xdd,
	0x37, 0x36, 0x1f, 0x98, 0xc5, 0xe2, 0xf0, 0x22, 0xae, 0x45, 0x30, 0x68, 0x18, 0xde, 0x97, 0x5c,
	0x57, 0xc3, 0x43, 0x14, 0x76, 0x72, 0x22, 0x53, 0x9e, 0x86, 0x22, 0x18, 0x36, 0x74, 0xf2, 0xd0,
	0xd8, 0x7c, 0x27, 0x16, 0x8b, 0x13, 0x35, 0xe3, 0xe1, 0x53, 0xa1, 0x82, 0xad, 0x86, 0x89, 0x7a,
	0x44, 0x26, 0x3f, 0x51, 0x06, 0x89, 0x99, 0x90, 0xa9, 0x16, 0x2a, 0x15, 0x3a, 0xb8, 0xd4, 0x90,
	0x89, 0x9f, 0x5a, 0xa3, 0xcf, 0x84, 0x43, 0xe3, 0x2e, 0x88, 0x33, 0x25, 0x92, 0x60, 0xbb, 0x61,
	0x17, 0xfc, 0x0c, 0x2d, 0x7e, 0x17, 0x10, 0x0e, 0x73, 0x90, 0xf2, 0x44, 0x04, 0x3b, 0x0d, 0x39,
	0x38, 0xe2, 0x49, 0x95, 0x03, 0x44, 0x61, 0x30, 0x69, 0x99, 0x4c, 0x84, 0x0a, 0x58, 0x43, 0x30,
	0x47, 0x64, 0xf2, 0xc1, 0x18, 0x24, 0x3b, 0x84, 0x41, 0x3e, 0xcb, 0x52, 0x31, 0xb6, 0x9e, 0x97,
	0xc9, 0xf3, 0xda, 0x9c, 0xe7, 0x63, 0x04, 0xcc, 0xbb, 0xf7, 0xf3, 0x4a, 0x87, 0xa3, 0xd4, 0x82,
	0x27, 0xc1, 0x95, 0x86, 0x51, 0x7e, 0x25, 0x78, 0xb5, 0xfb, 0x10, 0x45, 0x68, 0x99, 0x88, 0xe0,
	0x6a, 0x13, 0x5a, 0xd6, 0x62, 0x42, 0x14, 0xdb, 0x87, 0xae, 0x12, 0xb9, 0xe0, 0x5a, 0x44, 0xc1,
	0xee, 0x41, 0xeb, 0xe6, 0x10, 0x13, 0xea, 0x34, 0xec, 0x0a, 0xac, 0x17, 0x4f, 0x65, 0x1e, 0xbc,
	0x7e, 0xd0, 0xba, 0xd9, 0x45, 0x1f, 0x94, 0x0e, 0x37, 0x60, 0x5d, 0x9f, 0xe7, 0x62, 0x74, 0x08,
	0x50, 0x51, 0x0b, 0xdb, 0xab, 0xb5, 0x84, 0x2c, 0x34, 0xac, 0xb5, 0x13, 0xe0, 0x12, 0x4d, 0xb5,
	0x48, 0x75, 0xd0, 0x3e, 0x68, 0xdf, 0xec, 0x1d, 0x3b, 0x71, 0x74, 0x0f, 0x7a, 0x9e, 0x6e, 0x2e,
	0x6a, 0xe2, 0x54, 0xa8, 0x42, 0x66, 0xa9, 0x6b, 0xc2, 0x8a, 0xa3, 0x7f, 0xb4, 0xa0, 0xe7, 0x49,
	0xe8, 0x82, 0x36, 0x36, 0x14, 0x4f, 0xa3, 0x2c, 0x21, 0xda, 0xc3, 0x80, 0xac, 0xcc, 0x76, 0xa1,
	0x73, 0x22, 0x55, 0xa1, 0x89, 0xe1, 0xd0, 0x60, 0x44, 0x4c, 0x40, 0xcc, 0x0b, 0x4d, 0x3c, 0x46,
	0x09, 0x40, 0x09, 0xd1, 0x32, 0x8d, 0xc4, 0x19, 0x71, 0x15, 0x66, 0xcc, 0x88, 0xa8, 0x37, 0x2c,
	0xbc, 0xe1, 0xf4, 0x86, 0x6c, 0x6f, 0xc2, 0x25, 0xd3, 0xcf, 0x38, 0xcd, 0xc6, 0x22, 0xc9, 0xf5,
	0x39, 0x51, 0x10, 0x36, 0x38, 0x34, 0x86, 0xa3, 0xec, 0x01, 0xaa, 0x7d, 0x6a, 0xff, 0xb4, 0x01,
	0x83, 0x3a, 0x4f, 0xae, 0x0c, 0xeb, 0x0a, 0xac, 0x87, 0x52, 0x9f, 0xfb, 0xa0, 0x48, 0x62, 0x6f,
	0x41, 0xbf, 0xd0, 0x4a, 0x08, 0x3d, 0xa6, 0x25, 0xee, 0x02, 0x03, 0xa3, 0xc4, 0xd5, 0xcd, 0xde,
	0x81, 0x2d, 0x0b, 0xa9, 0xf3, 0x35, 0x0d, 0xcb, 0xe8, 0xed, 0x10, 0xd8, 0x0f, 0x60, 0xa7, 0x10,
	0x61, 0x96, 0x46, 0x5c, 0x9d, 0x7b, 0x6c, 0xc7, 0x62, 0xb7, 0xbd, 0xe9, 0x9e, 0x67, 0xf2, 0x4b,
	0x93, 0x52, 0xc6, 0x91, 0x4c, 0xa7, 0x6e, 0xdd, 0x6f, 0x58, 0xf0, 0x96, 0x33, 0xd8, 0xb5, 0xbd,
	0x0f, 0xdd, 0x3c, 0x2b, 0x34, 0x11, 0xa5, 0xcb, 0x89, 0xd7, 0xb0, 0x23, 0xd8, 0x71, 0xdf, 0xe3,
	0xc9, 0xf9, 0xb8, 0xd0, 0x48, 0x58, 0x86, 0x85, 0x0f, 0x96, 0x9e, 0x29, 0x87, 0xe7, 0x4f, 0x10,
	0xf7, 0xe8, 0xb5, 0xe3, 0x4b, 0xce, 0xd9, 0xaa, 0xd8, 0x1b, 0xd0, 0x7d, 0x2e, 0xf3, 0xb1, 0xa7,
	0x65, 0xec, 0x6d, 0xf3, 0xb9, 0xcc, 0x91, 0x8e, 0xd9, 0xcf, 0x61, 0xc7, 0x19, 0xab, 0xce, 0xe0,
	0xa5, 0x3b, 0xdb, 0xb2, 0xed, 0xb8, 0xbe, 0xae, 0x41, 0x0f, 0x77, 0xd8, 0xf8, 0x79, 0x96, 0x0a,
	0x22, 0x66, 0x0a, 0x0d, 0x55, 0xdf, 0x66, 0xa9, 0xc0, 0xe9, 0xc1, 0x69, 0x1a, 0xe7, 0x4a, 0x9c,
	0xc8, 0x33, 0x62, 0x61, 0x9a, 0x1e, 0x54, 0x3e, 0x26, 0x9d, 0x87, 0x14, 0xe5, 0x09, 0x42, 0x86,
	0x75, 0xc8, 0x13, 0xd2, 0xb1, 0xb7, 0xc1, 0xce, 0x94, 0x03, 0x6d, 0x59, 0xd0, 0xc0, 0xa8, 0x2d,
	0x6c, 0x17, 0x3a, 0x26, 0x9c, 0x4b, 0x6e, 0x79, 0x93, 0xc8, 0xae, 0x03, 0xd0, 0xc7, 0x98, 0x4f,
	0x26, 0x8a, 0x58, 0x13, 0x8d, 0x3d, 0xd2, 0xdd, 0x9b, 0x4c, 0x14, 0xdb, 0xc3, 0x8d, 0x5b, 0xa6,
	0x5a, 0x9d, 0x13, 0x47, 0x76, 0xcd, 0x01, 0x42, 0x0a, 0x76, 0x03, 0x06, 0xf6, 0xd3, 0x24, 0x94,
	0x59, 0x40, 0xdf, 0x6a, 0x29, 0xa9, 0xfb, 0xd0, 0x8d, 0xb9, 0x96, 0xba, 0x8c, 0x04, 0x71, 0x1f,
	0x25, 0xc1, 0x69, 0xd8, 0x9b, 0xd0, 0x8b, 0xb3, 0x74, 0x6a, 0xcc, 0x57, 0x5c, 0xf7, 0x5e, 0x85,
	0x1b, 0xb6, 0xd0, 0x4a, 0xa6, 0x53, 0x62, 0x33, 0xda, 0xb0, 0x46, 0xf6, 0x1b, 0xe5, 0xfb, 0x70,
	0xb9, 0x61, 0x3a, 0xd8, 0x15, 0x17, 0x70, 0x8b, 0xb8, 0xc2, 0x08, 0xa3, 0x3f, 0xb4, 0xa0, 0xeb,
	0x4a, 0x89, 0x8b, 0x76, 0x14, 0x6d, 0x1a, 0xbf, 0xa3, 0x88, 0xff, 0xf7, 0x2a, 0x0a, 0x72, 0xbb,
	0xc9, 0x29, 0x70, 0xa4, 0xbc, 0xd4, 0xb3, 0x4c, 0xf9, 0x2d, 0x64, 0xe5, 0x5a, 0x0c, 0x9d, 0x25,
	0x31, 0xfc, 0x06, 0xfa, 0xb5, 0x92, 0x65, 0xe5, 0xc0, 0x6e, 0xc3, 0x5a, 0xa9, 0x62, 0x5b, 0xb5,
	0xbd, 0xd1, 0x50, 0xf5, 0x7c, 0xad, 0x62, 0x5f, 0x29, 0x95, 0x2a, 0xae, 0xf5, 0xbe, 0xb6, 0xa4,
	0xf7, 0x6f, 0x60, 0x6b, 0xde, 0x95, 0xed, 0xc2, 0xc6, 0x49, 0xa6, 0x12, 0xae, 0x6d, 0xf6, 0xac,
	0x84, 0x49, 0x7d, 0x26, 0x23, 0x3d, 0x23, 0x02, 0x5e, 0x3f, 0x36, 0x02, 0xa2, 0x67, 0x42, 0x4e,
	0x67, 0xc8, 0x9d, 0xa8, 0xb6, 0xd2, 0x68, 0x06, 0x83, 0x7a, 0x4d, 0xb5, 0x32, 0xac, 0xbd, 0xaa,
	0x62, 0x74, 0x29, 0xf7, 0x65, 0xe1, 0xc5, 0x11, 0x7c, 0xd7, 0x82, 0xe1, 0x5c, 0x19, 0xb6, 0xb2,
	0xaf, 0x5b, 0xc0, 0x42, 0x25, 0x22, 0xa9, 0xc7, 0x21, 0x57, 0x91, 0xe3, 0x27, 0xd7, 0xed, 0xb6,
	0xb1, 0xdd, 0xe7, 0x2a, 0xb2, 0x0c, 0xf5, 0x31, 0xbc, 0x5e, 0xc7, 0x8b, 0xb3, 0x5c, 0xaa, 0xf3,
	0x31, 0x95, 0x4e, 0x6e, 0x40, 0x57, 0x2a, 0xa7, 0x07, 0x64, 0xc6, 0xfa, 0x89, 0xbd, 0x0b, 0xdb,
	0x75, 0x47, 0x1c, 0xaa, 0x5f, 0x1c, 0x5b, 0x95, 0xc7, 0x57, 0xe7, 0xb9, 0xf0, 0xa1, 0xfc, 0xb5,
	0x05, 0x3d, 0x5f, 0x1b, 0x5e, 0x74, 0x96, 0xc9, 0x62, 0x92, 0xde, 0x79, 0xbf, 0x3a, 0xcb, 0x8c,
	0xec, 0x2d, 0x1f, 0x54, 0x09, 0x33, 0x32, 0xd2, 0x80, 0xe0, 0x68, 0x70, 0xc3, 0x30, 0x22, 0x2e,
	0x77, 0xc1, 0xd3, 0x4f, 0xfc, 0x02, 0x25, 0x89, 0x31, 0x58, 0x53, 0xa5, 0xf6, 0xcc, 0x8d, 0x02,
	0xea, 0xf8, 0x24, 0xf5, 0x4c, 0x8d, 0x82, 0x1f, 0xfb, 0x9f, 0x5b, 0x30, 0x9c, 0xab, 0x52, 0x57,
	0x8e, 0x7f, 0x17, 0x3a, 0x61, 0x16, 0x67, 0x55, 0xe6, 0x8d, 0xc8, 0x0e, 0x00, 0x22, 0x91, 0x73,
	0xa5, 0x13, 0xac, 0x16, 0xfc, 0xa9, 0x55, 0xe9, 0x90, 0x77, 0x72, 0x95, 0x45, 0x65, 0x68, 0x4f,
	0x36, 0x17, 0x4c, 0xdf, 0x6a, 0xe9, 0x68, 0xdb, 0x85, 0x4e, 0xae, 0x64, 0x28, 0x7c, 0x4c, 0x46,
	0xf4, 0x83, 0xfd, 0x6d, 0x1b, 0x06, 0xf5, 0xca, 0xf8, 0x15, 0xe8, 0x00, 0x17, 0xa6, 0x21, 0xdd,
	0x6a, 0x61, 0x1a, 0xba, 0x45, 0x66, 0xe4, 0x3a, 0x9c, 0x8d, 0xf3, 0x99, 0xe2, 0x45, 0x6d, 0x84,
	0xa4, 0x7d, 0x4c, 0x4a, 0xb6, 0x0d, 0xed, 0x49, 0x75, 0x88, 0xb6, 0x27, 0x05, 0x26, 0x57, 0xc8,
	0xb4, 0x4a, 0xb8, 0x90, 0x29, 0x9e, 0x01, 0x51, 0x99, 0x16, 0x6e, 0x99, 0x6e, 0xfa, 0x7c, 0x94,
	0x69, 0x61, 0x17, 0x28, 0xd6, 0x28, 0xd9, 0x34, 0xa3, 0x73, 0xd1, 0xd4, 0x28, 0xd9, 0x34, 0xab,
	0x6d, 0x9b, 0xde, 0x92, 0x6d, 0xf3, 0xfb, 0x36, 0xf4, 0x7c, 0xa1, 0x7f, 0xc1, 0x5c, 0x39, 0x42,
	0xc0, 0x0c, 0x54, 0x84, 0xf0, 0x23, 0xd8, 0x9c, 0x08, 0xfd, 0x4c, 0x88, 0xd4, 0xde, 0x0c, 0xaf,
	0x35, 0xdf, 0x22, 0x0e, 0x0d, 0x88, 0xae, 0x55, 0xe6, 0x13, 0x77, 0xfc, 0x49, 0xa6, 0x9e, 0x71,
	0x15, 0x51, 0x76, 0x7a, 0x74, 0x69, 0x30, 0x0a, 0x3c, 0x33, 0x26, 0x3c, 0x7c, 0x4a, 0xc6, 0x8e,
	0x35, 0x7a, 0x0d, 0xfb, 0x1c, 0xba, 0x13, 0xa9, 0xf4, 0x2c, 0xe2, 0xe7, 0xf6, 0xf6, 0xf7, 0xe6,
	0x92, 0x5e, 0x2d, 0x8a, 0xbc, 0xed, 0x37, 0xe6, 0x38, 0xcd, 0x9e, 0x55, 0x0b, 0x38, 0xcd, 0x9e,
	0xf9, 0x84, 0x7c, 0x0c, 0x3b, 0x2f, 0x38, 0xb3, 0x6d, 0x58, 0x4b, 0x64, 0x4a, 0x4c, 0xd8, 0x39,
	0xc6, 0x4f, 0xd2, 0xf0, 0x33, 0x22, 0x41, 0xd4, 0xf0, 0xb3, 0xd1, 0x47, 0xb0, 0xbd, 0x18, 0x2b,
	0x63, 0xb0, 0x7e, 0xa2, 0xb2, 0xc4, 0x52, 0x28, 0x7d, 0xb3, 0x2d, 0x68, 0xeb, 0xcc, 0x96, 0xaf,
	0x6d, 0x9d, 0x8d, 0x9e, 0xc3, 0xa0, 0x7e, 0x71, 0x5a, 0x39, 0x07, 0x0f, 0xa1, 0x5f, 0x63, 0x13,
	0x7b, 0x02, 0xdc, 0x58, 0x7a, 0x09, 0xbb, 0xef, 0xf9, 0x85, 0x2a, 0x06, 0x2f, 0xf9, 0x60, 0xdf,
	0x83, 0xdd, 0x66, 0x3c, 0x8e, 0x9c, 0xb8, 0xca, 0x8e, 0xdc, 0xad, 0x95, 0x7e, 0xed, 0xb6, 0xb6,
	0x72, 0xa4, 0xef, 0xc3, 0xe5, 0x82, 0x9f, 0x8f, 0x8b, 0x2c, 0x11, 0x7a, 0x86, 0x25, 0x60, 0x91,
	0x70, 0xa5, 0xfd, 0xe6, 0xd9, 0x29, 0xf8, 0xf9, 0x13, 0x67, 0x7b, 0x82, 0x26, 0xf6, 0xff, 0x30,
	0xc0, 0x02, 0x44, 0x9c, 0x4a, 0xae, 0xeb, 0xa7, 0xeb, 0x9c, 0x16, 0x8b, 0x05, 0x1e, 0xfd, 0x5a,
	0x84, 0x5a, 0x9e, 0x56, 0x5b, 0xaa, 0x52, 0xd1, 0x2e, 0xcd, 0xca, 0xb4, 0x62, 0x31, 0x94, 0x50,
	0x7b, 0x2a, 0xd4, 0xc4, 0xef, 0x2a, 0x92, 0xb0, 0x10, 0xc4, 0x91, 0x91, 0xc5, 0xad, 0x85, 0x4d,
	0x99, 0x4e, 0xbf, 0x41, 0xe3, 0x1e, 0x6c, 0x9a, 0x8d, 0x5b, 0xf8, 0x3d, 0xe5, 0x14, 0x3e, 0x7d,
	0xff, 0x5e, 0x83, 0xe1, 0xdc, 0x45, 0xf4, 0x22, 0xb2, 0x13, 0x09, 0x97, 0x71, 0x45, 0x76, 0x24,
	0x62, 0xfd, 0x75, 0xa2, 0x84, 0x18, 0x1b, 0xa3, 0x0b, 0xbb, 0x87, 0xba, 0x07, 0x0e, 0x50, 0xf0,
	0x13, 0x07, 0xf0, 0x41, 0xa3, 0xce, 0x00, 0xae, 0x41, 0xaf, 0x2c, 0x84, 0x32, 0x4c, 0xe8, 0x22,
	0xef, 0xa2, 0x8a, 0x68, 0xf0, 0x0b, 0xe8, 0xe6, 0xbc, 0x28, 0x9e, 0x65, 0x2a, 0xb2, 0x9b, 0x65,
	0xb4, 0xfc, 0x2e, 0xfd, 0xd8, 0x22, 0xa9, 0x04, 0xb7, 0xdf, 0x44, 0x40, 0x59, 0xc2, 0x65, 0x6a,
	0xba, 0xa8, 0x08, 0x88, 0x94, 0xd4, 0x49, 0x05, 0xa1, 0x7e, 0xba, 0xf3, 0x90, 0x5f, 0x61, 0x2b,
	0x6f, 0xc3, 0xd0, 0x42, 0x2c, 0x65, 0x3a, 0x52, 0x1a, 0x18, 0xb5, 0xad, 0x53, 0xdf, 0x82, 0x7e,
	0xc2, 0x43, 0x7f, 0xc3, 0x00, 0xd7, 0x52, 0xc2, 0x43, 0x77, 0xb7, 0xb8, 0x01, 0x03, 0x99, 0x9f,
	0xfe, 0xd0, 0x63, 0x5c, 0x65, 0xdd, 0x47, 0xed, 0x3c, 0xe8, 0x23, 0x0f, 0x1a, 0xd4, 0x40, 0x1f,
	0x39, 0x10, 0x33, 0xb5, 0x94, 0x2b, 0xab, 0xa9, 0x5c, 0xc2, 0x0b, 0x6f, 0x5c, 0x4e, 0x7d, 0x19,
	0x4d, 0x92, 0x9f, 0xf4, 0xcf, 0xe0, 0x6a, 0x63, 0xc2, 0x5e, 0x8a, 0x24, 0xfe, 0xb5, 0x06, 0x50,
	0xbd, 0x41, 0xac, 0x5c, 0x2e, 0x6f, 0x42, 0x2f, 0x9c, 0x71, 0xc5, 0x43, 0x5d, 0xab, 0x4c, 0x2a,
	0x15, 0xfb, 0x1c, 0xc0, 0x0b, 0x85, 0xa5, 0xde, 0xbd, 0x25, 0x8f, 0x1d, 0x47, 0x65, 0x42, 0x0c,
	0xe0, 0xf1, 0x18, 0x23, 0xcd, 0x93, 0xbf, 0xd3, 0x52, 0x08, 0x77, 0xa1, 0x83, 0xbf, 0x85, 0x7d,
	0x7f, 0x5b, 0xdd, 0x9c, 0x81, 0xb2, 0x1f, 0x43, 0xb7, 0x10, 0x78, 0x8f, 0x0f, 0x85, 0x5d, 0x5d,
	0xd7, 0x97, 0xb8, 0x3d, 0xb1, 0x30, 0x5c, 0x5a, 0xce, 0x85, 0x7d, 0x0a, 0x3d, 0xf7, 0x5d, 0xd8,
	0x37, 0xb9, 0xd5, 0xdd, 0x56, 0x70, 0xf6, 0x05, 0xf4, 0x72, 0xae, 0xf8, 0x54, 0xf1, 0x7c, 0xd6,
	0x78, 0x23, 0xac, 0x7c, 0x1f, 0x3b, 0x1c, 0xb6, 0xe0, 0x9d, 0x30, 0x89, 0x5e, 0x28, 0xec, 0x23,
	0xdd, 0x05, 0x49, 0xac, 0xf0, 0xb5, 0xe3, 0x15, 0x96, 0x1c, 0xaf, 0x6f, 0xc1, 0x70, 0xae, 0x01,
	0x5c, 0x12, 0x69, 0x69, 0x0e, 0x84, 0xe1, 0x31, 0x7e, 0x8e, 0xde, 0x05, 0xf6, 0x62, 0x8a, 0xa8,
	0xcc, 0xa6, 0x99, 0x30, 0x48, 0x23, 0x8c, 0xee, 0xc0, 0xe5, 0x86, 0x90, 0x70, 0x19, 0xf9, 0x29,
	0x30, 0x78, 0x2f, 0x8f, 0xfe, 0xd9, 0x82, 0x9e, 0x7f, 0xc5, 0x7a, 0x85, 0x02, 0x07, 0xd9, 0x49,
	0xaa, 0x62, 0xe1, 0x01, 0xa1, 0x47, 0x3a, 0xda, 0xf8, 0xd7, 0xa0, 0x17, 0xf3, 0x62, 0xa1, 0x0c,
	0xeb, 0xa2, 0xea, 0xc8, 0x16, 0x48, 0xf6, 0x76, 0xeb, 0x6f, 0x3e, 0x46, 0xae, 0x95, 0x4e, 0x1b,
	0x0b, 0xa5, 0xd3, 0x2e, 0x74, 0xb4, 0xd4, 0x71, 0x45, 0x34, 0x46, 0xac, 0xe5, 0xbb, 0xbb, 0x24,
	0xdf, 0x7f, 0x5b, 0x83, 0x7e, 0xed, 0x11, 0x6d, 0x65, 0xbc, 0x1f, 0xfb, 0x97, 0xbc, 0x76, 0x43,
	0xdd, 0x52, 0x6b, 0xe5, 0x4b, 0x39, 0x95, 0xba, 0xf6, 0x9c, 0xf7, 0x19, 0x6c, 0x46, 0x22, 0x94,
	0x09, 0x8f, 0xed, 0xb6, 0xbb, 0xbe, 0xd4, 0xd3, 0xc0, 0xf0, 0xec, 0xb0, 0x1e, 0x18, 0x5b, 0x84,
	0xed, 0x55, 0xe5, 0x37, 0x89, 0xec, 0x1e, 0xf4, 0x67, 0xe2, 0x8c, 0xbb, 0x86, 0x3b, 0x2f, 0x37,
	0xa4, 0xba, 0x0f, 0x8e, 0xcb, 0x55, 0x62, 0x1b, 0xab, 0xc7, 0xd5, 0x50, 0x8b, 0xfd, 0x84, 0xde,
	0x60, 0x24, 0x9d, 0xab, 0x9b, 0x0d, 0x5b, 0xa9, 0xe6, 0xfd, 0xd8, 0xe2, 0xec, 0x2b, 0x0d, 0x7d,
	0xa3, 0x7f, 0x2a, 0xa6, 0x9c, 0xfc, 0xbb, 0xab, 0xfd, 0x8f, 0x2c, 0x0e, 0xfd, 0x9d, 0x8f, 0x9f,
	0xc1, 0x77, 0x61, 0x7b, 0x31, 0x4e, 0x2c, 0x3d, 0x29, 0x49, 0x6e, 0x37, 0x58, 0x69, 0xf4, 0x08,
	0xd8, 0x8b, 0xc9, 0x66, 0xfb, 0xd0, 0xcb, 0x95, 0x08, 0x25, 0xdd, 0xd1, 0x8d, 0x43, 0xa5, 0xa0,
	0x47, 0x81, 0x90, 0xc7, 0x82, 0x58, 0x79, 0x78, 0x6c, 0x84, 0xd1, 0x27, 0x73, 0x2d, 0xb9, 0xf2,
	0xad, 0xc6, 0xe8, 0xc3, 0x17, 0x18, 0x7d, 0x68, 0x18, 0xfd, 0x1d, 0xb8, 0xdc, 0x90, 0x1a, 0x07,
	0x6c, 0x2d, 0x03, 0xba, 0x1c, 0xbc, 0x78, 0x6a, 0x8c, 0x0e, 0xe6, 0x32, 0x70, 0x3f, 0x2b, 0x53,
	0xcd, 0x06, 0xd0, 0x0a, 0x2d, 0xa6, 0x15, 0x8e, 0x3e, 0x80, 0x9d, 0x45, 0xc4, 0x5d, 0xac, 0x2b,
	0xc3, 0x3b, 0x16, 0xd3, 0x0e, 0xef, 0x90, 0x7c, 0xd7, 0x9e, 0x3d, 0xed, 0xf0, 0xee, 0xe8, 0x2f,
	0x6d, 0xd8, 0x5e, 0x7c, 0x64, 0x5e, 0xb9, 0x3f, 0x6e, 0x2c, 0xbc, 0x5a, 0xb7, 0xfd, 0x15, 0xab,
	0xf6, 0x2c, 0x7d, 0x1d, 0x20, 0x14, 0x71, 0x3c, 0x26, 0x5d, 0x45, 0x0f, 0xa8, 0xa3, 0xce, 0x90,
	0x1e, 0xb8, 0x12, 0xdc, 0xbc, 0x0e, 0x79, 0x7a, 0x40, 0x15, 0x3d, 0x0d, 0xbd, 0x0d, 0x43, 0x71,
	0x16, 0xce, 0x78, 0x3a, 0x15, 0x06, 0xe2, 0x58, 0x62, 0xe0, 0xd4, 0x04, 0xfb, 0x25, 0xec, 0x14,
	0xe5, 0xa4, 0x08, 0x95, 0x9c, 0x60, 0x9d, 0x53, 0x3d, 0x27, 0x2e, 0xd6, 0x32, 0x8b, 0x11, 0xba,
	0x8d, 0xb2, 0x5d, 0xb9, 0xdb, 0x91, 0x57, 0x64, 0xb2, 0xb9, 0x84, 0x4c, 0x6e, 0xc3, 0xd5, 0xc6,
	0xe6, 0x96, 0xae, 0xc7, 0x3f, 0xb6, 0xa0, 0xe7, 0xdf, 0xe2, 0x5f, 0x81, 0x6b, 0xf7, 0xa1, 0x1b,
	0x2a, 0xc1, 0x75, 0xa9, 0xaa, 0x54, 0x7a, 0x4d, 0xf5, 0x7e, 0xb7, 0x3e, 0xff, 0x7e, 0x77, 0xf1,
	0xdb, 0x12, 0x5e, 0xf2, 0xfc, 0xab, 0xff, 0x7f, 0xe3, 0x92, 0xe7, 0x1b, 0xff, 0x9f, 0x5e, 0xf2,
	0xaa, 0x5e, 0x5f, 0xe1, 0x92, 0xf7, 0x82, 0xf3, 0xcb, 0x5e, 0xf2, 0x16, 0x63, 0x7d, 0x99, 0x4b,
	0xde, 0xa7, 0x1f, 0xc2, 0x46, 0x9c, 0x21, 0xd3, 0xb0, 0xfd, 0x5b, 0xe6, 0xaf, 0xdd, 0x5b, 0xee,
	0xaf, 0xdd, 0x5b, 0x0f, 0x65, 0x2c, 0x7e, 0x91, 0xe3, 0xed, 0xa6, 0x08, 0xbe, 0x13, 0x26, 0xed,
	0x06, 0xfc, 0xe9, 0x31, 0x74, 0x4e, 0xa4, 0x88, 0x23, 0x76, 0xad, 0xc1, 0x4b, 0xc4, 0x91, 0x73,
	0xfb, 0xbb, 0xa0, 0xf4, 0xec, 0x2f, 0xdc, 0x04, 0xe7, 0xfe, 0x1e, 0x3e, 0x36, 0x4d, 0x1d, 0x0e,
	0xbf, 0xad, 0xff, 0x17, 0xfd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x65, 0x75, 0xd7, 0x6e, 0xac,
	0x1e, 0x00, 0x00,
}
