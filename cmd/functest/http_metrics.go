// Code generated by protoc-gen-gomeet-service. DO NOT EDIT.
// source: pb/profile.proto
package functest

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
)

func TestHttpMetrics(config FunctionalTestConfig) []TestFailure {
	var failures []TestFailure

	client, serverAddr, proto, err := httpClient(config)
	if err != nil {
		failures = append(failures, TestFailure{Procedure: "Metrics/HTTP", Message: fmt.Sprintf("HTTP client initialization error (%v)", err)})
		return failures
	}

	url := fmt.Sprintf("%s://%s/metrics", proto, serverAddr)

	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", config.JsonWebToken))

	resp, err := client.Do(req)
	if err != nil {
		failures = append(failures, TestFailure{Procedure: "Metrics/HTTP", Message: fmt.Sprintf("HTTP GET error on %s (%v)", url, err)})
		return failures
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	if fmt.Sprintf("%s", body) == "" {
		failures = append(failures, TestFailure{Procedure: "Metrics/HTTP", Message: "response should contain metrics data"})
		return failures
	}

	patternsToMatch := []string{
		"^process_cpu_seconds_total",
		"^process_open_fds",
		"^process_resident_memory_bytes",
		"^process_start_time_seconds",
		"^process_virtual_memory_bytes",
		"^go_goroutines",
		"^go_memstats_alloc_bytes",
	}

	routeMap := map[string]string{
		"/api/v1/services/status": "Api.ServicesStatus",
		"/api/v1/hard_delete":     "Api.HardDelete",
		"/api/v1/version":         "Api.Version",
		"/api/v1/create":          "Api.Create",
		"/api/v1/read":            "Api.Read",
		"/api/v1/list":            "Api.List",
		"/api/v1/update":          "Api.Update",
		"/api/v1/soft_delete":     "Api.SoftDelete",
	}

	for _, label := range routeMap {
		for _, lblMethod := range strings.Split(label, "|") {
			method := strings.TrimPrefix(lblMethod, "Api.")
			patternsToMatch = append(patternsToMatch, fmt.Sprintf("^grpc_server_handled_total.+grpc_method=\"%s\"", method))
			patternsToMatch = append(patternsToMatch, fmt.Sprintf("^grpc_server_msg_received_total.+grpc_method=\"%s\"", method))
			patternsToMatch = append(patternsToMatch, fmt.Sprintf("^grpc_server_msg_sent_total.+grpc_method=\"%s\"", method))
		}
		escapedLabel := strings.Replace(label, "|", "\\|", -1)
		patternsToMatch = append(patternsToMatch, fmt.Sprintf("^http_request_duration_microseconds.+handler=\"%s\"", escapedLabel))
		patternsToMatch = append(patternsToMatch, fmt.Sprintf("^http_request_size_bytes.+handler=\"%s\"", escapedLabel))
	}

	buf := bytes.NewBuffer(body)
	lines := strings.Split(buf.String(), "\n")
	for _, pattern := range patternsToMatch {
		re, err := regexp.Compile(pattern)
		if err != nil {
			failures = append(failures, TestFailure{Procedure: "Metrics/HTTP", Message: fmt.Sprintf("could not compile regular expression \"%s\" (%v)", pattern, err)})
			continue
		}

		matched := false
		for _, line := range lines {
			if re.MatchString(line) {
				matched = true
				break
			}
		}

		if !matched {
			failures = append(failures, TestFailure{Procedure: "Metrics/HTTP", Message: fmt.Sprintf("could not match regular expression \"%s\" in metrics output", pattern)})
		}
	}

	return failures
}
